This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-03T12:51:39.235Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
scripts/
  package.json
  triangulate.js
src/
  api/
    controllers/
      Controller.php
      GenerateController.php
    models/
      Triangle3D.php
      Vector3D.php
    services/
      GeminiService.php
      ImageProcessor.php
      STLConverter.php
    tests/
      STLConverterTest.php
  public/
    .htaccess
    index.html
    index.php
    repomix-output.txt
test_data/
  problematic.svg
.env.example
.gitignore
check_svg.php
composer.json
package.json
plan.md
refined_plan.md

================================================================
Files
================================================================

================
File: scripts/package.json
================
{
  "type": "module",
  "dependencies": {
    "@types/three": "^0.162.0",
    "earcut": "^3.0.1",
    "jsdom": "^24.0.0",
    "three": "^0.163.0",
    "three-bvh-csg": "^0.0.16"
  }
}

================
File: scripts/triangulate.js
================
import * as THREE from 'three';
import { JSDOM } from 'jsdom';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader.js';
import { STLExporter } from 'three/examples/jsm/exporters/STLExporter.js';
import { Brush, Evaluator, ADDITION } from 'three-bvh-csg'; // Import CSG tools
import * as fs from 'node:fs/promises'; // Keep for potential future use

// --- JSDOM Setup ---
const dom = new JSDOM('<!DOCTYPE html><html><body></body></html>');
global.window = dom.window;
global.document = window.document;
global.DOMParser = window.DOMParser;
global.XMLSerializer = window.XMLSerializer;

// --- Canvas Mock ---
class CanvasMock {
  constructor() { this.style = {}; }
  getContext() {
    return {
      fillRect: () => {}, clearRect: () => {}, getImageData: (x, y, w, h) => ({ data: new Array(w * h * 4) }),
      putImageData: () => {}, createImageData: () => ({data: []}), setTransform: () => {}, drawImage: () => {},
      save: () => {}, restore: () => {}, scale: () => {}, translate: () => {}, fill: () => {}, stroke: () => {},
      beginPath: () => {}, moveTo: () => {}, lineTo: () => {}, closePath: () => {}, arc: () => {}, rect: () => {}
    };
  }
}
global.document.createElement = (type) => {
  if (type === 'canvas') return new CanvasMock();
  return dom.window.document.createElement(type);
};
// --- End JSDOM Setup ---// --- End JSDOM Setup ---


// --- Enhanced isBlackOrDark Function ---
function isBlackOrDark(color) {
    if (!color || color === 'none') return false;
    color = color.toLowerCase().trim();

    // Direct match for common dark colors
    const darkColors = [
        'black', '#000', '#000000', 'rgb(0,0,0)', 'rgba(0,0,0,1)',
        'darkblue', 'darkred', 'darkgreen', 'darkmagenta', 'darkcyan',
        'darkslategray', 'darkslategrey', 'darkviolet', 'navy', 'maroon'
    ];
    if (darkColors.includes(color)) return true;

    // Named CSS colors that should be considered dark
    const namedDarkColors = {
        'blue': true, 'brown': true, 'crimson': true, 'firebrick': true,
        'indigo': true, 'midnightblue': true, 'purple': true, 'rebeccapurple': true,
        'saddlebrown': true, 'sienna': true, 'teal': true
    };
    if (namedDarkColors[color]) return true;

    // Calculate perceived brightness using the formula
    // Perceived brightness = 0.299*R + 0.587*G + 0.114*B
    const calculateBrightness = (r, g, b) => 0.299 * r + 0.587 * g + 0.114 * b;
    const DARKNESS_THRESHOLD = 120; // Increased threshold to catch more colors

    try {
        // Handle hex colors
        if (color.startsWith('#')) {
            let hex = color.substring(1);
            if (hex.length === 3) hex = hex.split('').map(char => char + char).join('');
            if (hex.length !== 6) return false;
            const bigint = parseInt(hex, 16);
            if (isNaN(bigint)) return false;
            const r = (bigint >> 16) & 255; const g = (bigint >> 8) & 255; const b = bigint & 255;
            return calculateBrightness(r, g, b) < DARKNESS_THRESHOLD;
        }

        // Handle rgb/rgba colors
        if (color.startsWith('rgb')) {
            const parts = color.match(/[\d.]+/g);
            if (parts && parts.length >= 3) {
                const r = parseFloat(parts[0]); const g = parseFloat(parts[1]); const b = parseFloat(parts[2]);
                if (isNaN(r) || isNaN(g) || isNaN(b)) return false;
                return calculateBrightness(r, g, b) < DARKNESS_THRESHOLD;
            }
        }

        // Handle hsl/hsla colors
        if (color.startsWith('hsl')) {
            const parts = color.match(/[\d.]+/g);
            if (parts && parts.length >= 3) {
                const h = parseFloat(parts[0]) / 360;
                const s = parseFloat(parts[1]) / 100;
                const l = parseFloat(parts[2]) / 100;
                if (isNaN(h) || isNaN(s) || isNaN(l)) return false;

                // Convert HSL to RGB
                let r, g, b;
                if (s === 0) {
                    r = g = b = l; // achromatic
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }

                // Convert to 0-255 range
                r = Math.round(r * 255);
                g = Math.round(g * 255);
                b = Math.round(b * 255);

                return calculateBrightness(r, g, b) < DARKNESS_THRESHOLD;
            }
        }
    } catch (e) {
        console.error(`Error parsing color '${color}':`, e);
        return false;
    }

    // If we can't determine, assume it's not dark
    return false;
}
// --- End Enhanced isBlackOrDark Function ---

process.stdin.setEncoding('utf8');
let input = '';
process.stdin.on('data', (chunk) => { input += chunk; });

// Helper function to normalize color to a standard format (hex)
function normalizeColor(color) {
  if (!color || color === 'none') return null;

  // Already a hex color
  if (color.startsWith('#')) {
    // Convert 3-digit hex to 6-digit
    if (color.length === 4) {
      return `#${color[1]}${color[1]}${color[2]}${color[2]}${color[3]}${color[3]}`;
    }
    return color.toLowerCase();
  }

  // Handle named colors
  if (!color.startsWith('rgb') && !color.startsWith('hsl')) {
    // Create a temporary element to use browser's color parsing
    try {
      // Simple mapping of common named colors to hex
      const namedColors = {
        'black': '#000000',
        'white': '#ffffff',
        'red': '#ff0000',
        'green': '#008000',
        'blue': '#0000ff',
        'yellow': '#ffff00',
        'purple': '#800080',
        'orange': '#ffa500',
        'brown': '#a52a2a',
        'pink': '#ffc0cb',
        'gray': '#808080',
        'grey': '#808080'
      };

      return namedColors[color.toLowerCase()] || '#000000'; // Default to black if unknown
    } catch (e) {
      console.error(`Error normalizing named color '${color}':`, e);
      return '#000000'; // Default to black
    }
  }

  // Handle rgb/rgba colors
  if (color.startsWith('rgb')) {
    try {
      const parts = color.match(/[\d.]+/g);
      if (parts && parts.length >= 3) {
        const r = parseInt(parts[0]);
        const g = parseInt(parts[1]);
        const b = parseInt(parts[2]);
        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
      }
    } catch (e) {
      console.error(`Error parsing RGB color '${color}':`, e);
    }
  }

  // Default fallback
  return '#000000';
}

// Helper function to get a simplified color name from hex
function getColorName(hexColor) {
  if (!hexColor) return 'default';

  // Remove the # prefix if present
  const hex = hexColor.startsWith('#') ? hexColor.substring(1).toLowerCase() : hexColor.toLowerCase();

  // Map of common colors to names
  const colorMap = {
    '000000': 'black',
    'ffffff': 'white',
    'ff0000': 'red',
    '00ff00': 'green',
    '0000ff': 'blue',
    'ffff00': 'yellow',
    '800080': 'purple',
    'ffa500': 'orange',
    'a52a2a': 'brown',
    'ffc0cb': 'pink',
    '808080': 'gray'
  };

  // Check for exact matches
  if (colorMap[hex]) {
    return colorMap[hex];
  }

  // For other colors, return a simplified version of the hex
  return hex.substring(0, 6);
}

// Helper function to determine if a path should be processed
function shouldProcessPath(style) {
  const fillColor = style?.fill;
  const strokeColor = style?.stroke;
  const hasStrokeWidth = style?.strokeWidth && parseFloat(style.strokeWidth) > 0;
  const fillOpacity = style?.fillOpacity !== undefined ? parseFloat(style.fillOpacity) : 1.0;

  // Check if the fill color is white or very light (which should be treated as holes)
  const isWhiteOrLight = (color) => {
    if (!color || color === 'none') return false;

    // Direct match for white
    if (['white', '#fff', '#ffffff', 'rgb(255,255,255)', 'rgba(255,255,255,1)'].includes(color.toLowerCase().trim())) {
      return true;
    }

    // Try to parse the color to check brightness
    try {
      const normalizedColor = normalizeColor(color);
      if (normalizedColor && normalizedColor.startsWith('#')) {
        // Convert hex to RGB
        const r = parseInt(normalizedColor.substring(1, 3), 16);
        const g = parseInt(normalizedColor.substring(3, 5), 16);
        const b = parseInt(normalizedColor.substring(5, 7), 16);

        // Calculate brightness (higher value means lighter color)
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness > 200; // Threshold for light colors
      }
    } catch (e) {
      console.error(`Error checking if color is light: ${color}`, e);
    }

    return false;
  };

  // Process only if:
  // 1. It has a fill that's not 'none' AND
  // 2. The fill is not white/very light AND
  // 3. The fill opacity is significant
  // OR
  // It has a dark stroke with width
  const hasDarkFill = fillColor && fillColor !== 'none' && !isWhiteOrLight(fillColor) && fillOpacity > 0.1;
  const hasDarkStroke = strokeColor && strokeColor !== 'none' && !isWhiteOrLight(strokeColor) && hasStrokeWidth;

  return hasDarkFill || hasDarkStroke;
}

process.stdin.on('end', async () => {
  try {
    const data = JSON.parse(input);
    const svgContent = data.svgContent;
    const extrusionDepth = data.extrusionDepth || 10;
    const curveSegments = data.curveSegments || 32;
    const binaryOutput = data.binary || false;
    const desiredMaxSize = data.maxSize || 100;
    const modelId = data.modelId || 'model';
    const uploadDir = data.uploadDir || '.';

    if (!svgContent) throw new Error("Missing svgContent in input JSON");
    console.error(`Received parameters: extrusionDepth=${extrusionDepth}, curveSegments=${curveSegments}, binary=${binaryOutput}, desiredMaxSize=${desiredMaxSize}, modelId=${modelId}`);

    // --- Three.js Setup ---
    const loader = new SVGLoader();
    console.error('Parsing SVG content of length:', svgContent.length);
    console.error('SVG content preview:', svgContent.substring(0, 200) + '...');

    // Preprocess SVG content to handle Potrace output
    let processedSvgContent = svgContent;

    // Check if this is a Potrace-generated SVG (usually contains specific patterns)
    const isPotraceOutput = svgContent.includes('Potrace') ||
                           svgContent.includes('<!DOCTYPE svg PUBLIC') ||
                           svgContent.includes('width="1024.000000pt"');

    if (isPotraceOutput) {
      console.error('Detected Potrace-generated SVG, applying preprocessing...');

      // Extract paths from Potrace SVG
      const pathRegex = /<path[^>]*d="([^"]*)"[^>]*>/g;
      let pathMatch;
      let pathsFound = [];

      while ((pathMatch = pathRegex.exec(svgContent)) !== null) {
        pathsFound.push(pathMatch[0]);
      }

      console.error(`Found ${pathsFound.length} path elements in Potrace SVG`);

      if (pathsFound.length === 0) {
        // If no paths found, look for polygons which Potrace sometimes uses
        const polygonRegex = /<polygon[^>]*points="([^"]*)"[^>]*>/g;
        let polygonMatch;
        let polygonsFound = [];

        while ((polygonMatch = polygonRegex.exec(svgContent)) !== null) {
          polygonsFound.push(polygonMatch[0]);
        }

        console.error(`Found ${polygonsFound.length} polygon elements in Potrace SVG`);

        if (polygonsFound.length > 0) {
          // Convert polygons to paths
          for (const polygon of polygonsFound) {
            const pointsMatch = polygon.match(/points="([^"]*)"/);
            if (pointsMatch && pointsMatch[1]) {
              const points = pointsMatch[1].trim().split(/\s+|,/);
              if (points.length >= 4) { // Need at least 2 points (4 coordinates)
                let pathD = `M${points[0]},${points[1]}`;
                for (let i = 2; i < points.length; i += 2) {
                  if (i + 1 < points.length) {
                    pathD += ` L${points[i]},${points[i+1]}`;
                  }
                }
                pathD += ' Z'; // Close the path
                const newPath = `<path d="${pathD}" fill="black"/>`;
                processedSvgContent = processedSvgContent.replace(polygon, newPath);
              }
            }
          }
        }
      }

      // If still no usable elements, create a simple shape
      if (pathsFound.length === 0 && !processedSvgContent.includes('<path')) {
        console.error('No usable elements found in SVG, creating a fallback shape');

        // Extract width and height from the SVG
        let width = 100, height = 100;
        const widthMatch = svgContent.match(/width="([^"]*)"/);
        const heightMatch = svgContent.match(/height="([^"]*)"/);

        if (widthMatch && widthMatch[1]) {
          width = parseFloat(widthMatch[1].replace('pt', ''));
        }

        if (heightMatch && heightMatch[1]) {
          height = parseFloat(heightMatch[1].replace('pt', ''));
        }

        // Create a simple rectangle path
        const fallbackPath = `<path d="M10,10 L${width-10},10 L${width-10},${height-10} L10,${height-10} Z" fill="black"/>`;

        // Find the closing </svg> tag and insert our path before it
        processedSvgContent = processedSvgContent.replace('</svg>', fallbackPath + '</svg>');
      }
    }

    let svgData;
    try {
      // Make sure processedSvgContent is defined and not empty
      if (!processedSvgContent || processedSvgContent.trim().length === 0) {
          throw new Error("SVG content provided to SVGLoader is empty.");
      }
      console.error(`Attempting to parse SVG content (length: ${processedSvgContent.length})`);
      svgData = loader.parse(processedSvgContent);
      console.error('SVG parsed without throwing an exception.');
    } catch (parseError) {
      console.error('FATAL: Error parsing SVG with SVGLoader:', parseError.message);
      console.error('--- Problematic SVG Content Start ---');
      console.error(processedSvgContent.substring(0, 1000) + (processedSvgContent.length > 1000 ? '...' : ''));
      console.error('--- Problematic SVG Content End ---');

      console.error('Attempting to create a minimal valid SVG as a last resort...');

      // Create a minimal valid SVG as a last resort
      const minimalSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
        <path d="M10,10 L90,10 L90,90 L10,90 Z" fill="black"/>
      </svg>`;

      try {
        svgData = loader.parse(minimalSvg);
        console.error('Minimal SVG parsed successfully');
        processedSvgContent = minimalSvg; // Use the minimal SVG for further processing
      } catch (fallbackError) {
        console.error('Failed to parse minimal SVG:', fallbackError.message);
        process.exit(1);
      }
    }

    // *** NEW: Robust check for loaded paths ***
    if (!svgData || !svgData.paths || svgData.paths.length === 0) {
      console.error('FATAL: SVGLoader parsed the SVG but found 0 usable paths in the svgData.paths array.');
      // Attempt to find elements manually for diagnostics
      try {
          const doc = new JSDOM(processedSvgContent).window.document;
          const pathElements = doc.querySelectorAll('path');
          const polygonElements = doc.querySelectorAll('polygon');
          console.error(`Diagnostic: Found ${pathElements.length} <path> elements via querySelectorAll.`);
          console.error(`Diagnostic: Found ${polygonElements.length} <polygon> elements via querySelectorAll.`);
          if (pathElements.length > 0) {
              console.error('Diagnostic: First path d attribute:', pathElements[0].getAttribute('d')?.substring(0, 100));
          }

          // If we found paths via DOM but SVGLoader didn't extract them, try to create paths manually
          if (pathElements.length > 0) {
              console.error('Attempting to manually create paths from DOM elements...');

              // Create a minimal SVG with the first path we found
              const firstPath = pathElements[0];
              const pathD = firstPath.getAttribute('d');
              const pathFill = firstPath.getAttribute('fill') || 'black';

              if (pathD) {
                  const manualSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
                    <path d="${pathD}" fill="${pathFill}"/>
                  </svg>`;

                  try {
                      svgData = loader.parse(manualSvg);
                      console.error('Manual path SVG parsed successfully');
                      processedSvgContent = manualSvg; // Use the manual SVG for further processing
                  } catch (manualError) {
                      console.error('Failed to parse manual path SVG:', manualError.message);
                      // Continue to fallback
                  }
              }
          }

          // If we still don't have paths, use the fallback
          if (!svgData || !svgData.paths || svgData.paths.length === 0) {
              console.error('Using fallback rectangle as a last resort...');
              const fallbackSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
                <path d="M10,10 L90,10 L90,90 L10,90 Z" fill="black"/>
              </svg>`;

              svgData = loader.parse(fallbackSvg);
              processedSvgContent = fallbackSvg;
          }
      } catch(domError) {
          console.error('Diagnostic: Error querying parsed SVG DOM:', domError.message);

          // Use fallback rectangle
          console.error('Using fallback rectangle after DOM error...');
          const fallbackSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
            <path d="M10,10 L90,10 L90,90 L10,90 Z" fill="black"/>
          </svg>`;

          svgData = loader.parse(fallbackSvg);
          processedSvgContent = fallbackSvg;
      }
    }
    // *** END NEW CHECK ***

    console.error(`SVGLoader successfully extracted ${svgData.paths.length} paths.`);

    // --- Group paths by color ---
    const colorGroups = {};
    const defaultGroup = 'default';

    // First pass: group paths by fill color
    svgData.paths.forEach((path, pathIndex) => {
      try {
        const style = path.userData?.style || {};
        const fillColor = style.fill;
        const strokeColor = style.stroke;

        console.error(`Path ${pathIndex} - Fill: ${fillColor}, Stroke: ${strokeColor}`);

        // Determine if this path should be processed
        if (shouldProcessPath(style)) {
          // Determine which color to use for grouping (prefer fill over stroke)
          const primaryColor = (fillColor && fillColor !== 'none') ? fillColor : strokeColor;
          const normalizedColor = normalizeColor(primaryColor);
          const colorKey = normalizedColor || defaultGroup;

          // Initialize color group if it doesn't exist
          if (!colorGroups[colorKey]) {
            colorGroups[colorKey] = {
              color: normalizedColor,
              colorName: getColorName(normalizedColor),
              paths: []
            };
          }

          // Add path to the appropriate color group
          colorGroups[colorKey].paths.push(path);
          console.error(`  Added path ${pathIndex} to color group: ${colorGroups[colorKey].colorName}`);
        } else {
          console.error(`  Skipping path ${pathIndex} because it has no fill or valid stroke.`);
        }
      } catch (error) {
        console.error(`  Error processing path ${pathIndex}:`, error.message || error);
      }
    });

    const colorKeys = Object.keys(colorGroups);
    console.error(`Created ${colorKeys.length} color groups: ${colorKeys.map(key => colorGroups[key].colorName).join(', ')}`);

    if (colorKeys.length === 0) {
      console.error("Warning: No processable paths found in any color group.");
      process.stdout.write('');
      process.exit(0);
    }

    // --- Process each color group separately ---
    const results = [];

    for (const colorKey of colorKeys) {
      const group = colorGroups[colorKey];
      console.error(`Processing color group: ${group.colorName} with ${group.paths.length} paths`);

      // Create a new scene for this color group
      const scene = new THREE.Scene();

      // Convert paths to shapes for this color group
      const shapes = [];

      // First, collect all paths and their winding directions
      const pathsWithInfo = [];
      group.paths.forEach((path, pathIndex) => {
        try {
          // Get the style information for this path
          const style = path.userData?.style || {};
          const fillColor = style.fill;
          const isWhiteFill = fillColor === 'white' || fillColor === '#fff' || fillColor === '#ffffff';

          // Process each subpath to determine its winding direction
          path.subPaths.forEach((subPath, subPathIndex) => {
            const points = subPath.getPoints();
            if (points.length < 3) return; // Need at least 3 points to form a shape

            // Calculate the signed area to determine winding direction
            // Positive area = counterclockwise (CCW), Negative area = clockwise (CW)
            let signedArea = 0;
            for (let i = 0; i < points.length; i++) {
              const j = (i + 1) % points.length;
              signedArea += points[i].x * points[j].y - points[j].x * points[i].y;
            }
            signedArea /= 2;

            // In SVG, outer shapes are typically CW and holes are CCW
            // But this can vary based on how the SVG was created
            const isCCW = signedArea > 0;
            const isHoleLike = isWhiteFill || (isCCW && !isWhiteFill); // White fill or CCW path is likely a hole

            pathsWithInfo.push({
              path: path,
              subPath: subPath,
              points: points,
              isCCW: isCCW,
              isHoleLike: isHoleLike,
              pathIndex: pathIndex,
              subPathIndex: subPathIndex,
              area: Math.abs(signedArea) // Absolute area for sorting by size
            });

            console.error(`  Path ${pathIndex}.${subPathIndex}: ${isCCW ? 'CCW' : 'CW'}, Area: ${Math.abs(signedArea).toFixed(2)}, Likely ${isHoleLike ? 'hole' : 'outer shape'}`);
          });
        } catch (error) {
          console.error(`  Error analyzing path ${pathIndex}:`, error.message);
        }
      });

      // Sort paths by area (largest first) to process outer shapes before holes
      pathsWithInfo.sort((a, b) => b.area - a.area);

      // First, create shapes from non-hole paths
      const mainShapes = [];
      const holeInfos = [];

      // Process outer shapes first
      pathsWithInfo.filter(info => !info.isHoleLike).forEach(info => {
        try {
          const shape = new THREE.Shape();
          const points = info.points;

          // Create the shape from points
          shape.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length; i++) {
            shape.lineTo(points[i].x, points[i].y);
          }
          shape.closePath();

          mainShapes.push({
            shape: shape,
            bounds: new THREE.Box2().setFromPoints(points),
            area: info.area,
            pathInfo: info
          });

          console.error(`  Created main shape from path ${info.pathIndex}.${info.subPathIndex} with area ${info.area.toFixed(2)}`);
        } catch (error) {
          console.error(`  Error creating main shape from path ${info.pathIndex}.${info.subPathIndex}:`, error.message);
        }
      });

      // Then collect hole paths
      pathsWithInfo.filter(info => info.isHoleLike).forEach(info => {
        holeInfos.push({
          points: info.points,
          bounds: new THREE.Box2().setFromPoints(info.points),
          area: info.area,
          pathInfo: info
        });
        console.error(`  Collected hole from path ${info.pathIndex}.${info.subPathIndex} with area ${info.area.toFixed(2)}`);
      });

      // Assign holes to their parent shapes
      holeInfos.forEach(holeInfo => {
        // Find the smallest containing shape for this hole
        let bestParent = null;
        let bestParentArea = Infinity;

        for (const shapeInfo of mainShapes) {
          // Check if the hole's bounds are completely inside the shape's bounds
          if (isBoxContained(holeInfo.bounds, shapeInfo.bounds)) {
            // Among containing shapes, pick the smallest one (smallest area)
            if (shapeInfo.area < bestParentArea) {
              bestParent = shapeInfo;
              bestParentArea = shapeInfo.area;
            }
          }
        }

        if (bestParent) {
          // Create a hole path and add it to the parent shape
          const holePath = new THREE.Path();
          const points = holeInfo.points;

          holePath.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length; i++) {
            holePath.lineTo(points[i].x, points[i].y);
          }
          holePath.closePath();

          // Add the hole to the parent shape
          bestParent.shape.holes.push(holePath);
          console.error(`  Added hole from path ${holeInfo.pathInfo.pathIndex}.${holeInfo.pathInfo.subPathIndex} to shape from path ${bestParent.pathInfo.pathIndex}.${bestParent.pathInfo.subPathIndex}`);
        } else {
          console.error(`  Warning: Could not find parent shape for hole from path ${holeInfo.pathInfo.pathIndex}.${holeInfo.pathInfo.subPathIndex}`);
        }
      });

      // Add all shapes to the final shapes array
      mainShapes.forEach(shapeInfo => {
        shapes.push(shapeInfo.shape);
      });

      // Helper function to check if one box is contained within another
      function isBoxContained(innerBox, outerBox) {
        return (
          innerBox.min.x >= outerBox.min.x &&
          innerBox.max.x <= outerBox.max.x &&
          innerBox.min.y >= outerBox.min.y &&
          innerBox.max.y <= outerBox.max.y
        );
      }

      console.error(`  Created ${shapes.length} shapes for color group: ${group.colorName}`);

      if (shapes.length === 0) {
        console.error(`  Warning: No shapes created for color group: ${group.colorName}`);
        continue; // Skip to next color group
      }

      // Create extrusion geometry
      const extrudeSettings = {
        depth: extrusionDepth,
        bevelEnabled: false,
        steps: 2,
        curveSegments: curveSegments
      };

      // Create material with the actual color from the SVG
      const material = new THREE.MeshStandardMaterial({
        color: group.color || 0xcccccc,
        flatShading: true
      });

      // Create meshes for each shape
      const initialMeshes = [];
      shapes.forEach((shape, index) => {
        try {
          const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
          const mesh = new THREE.Mesh(geometry, material);
          mesh.updateMatrixWorld();
          initialMeshes.push(mesh);
        } catch (extrudeError) {
          console.error(`  Error extruding shape ${index}:`, extrudeError);
        }
      });

      if (initialMeshes.length === 0) {
        console.error(`  Error: No meshes created for color group: ${group.colorName}`);
        continue; // Skip to next color group
      }

      // Perform CSG Union within this color group
      let finalMesh;
      if (initialMeshes.length === 1) {
        finalMesh = initialMeshes[0];
        console.error(`  Only one mesh in group ${group.colorName}, skipping CSG.`);
      } else {
        console.error(`  Starting CSG Union on ${initialMeshes.length} meshes for group ${group.colorName}...`);
        const csgEvaluator = new Evaluator();
        let resultBrush = new Brush(initialMeshes[0].geometry);
        resultBrush.applyMatrix4(initialMeshes[0].matrixWorld);

        for (let i = 1; i < initialMeshes.length; i++) {
          console.error(`    CSG Union: Result Brush + Mesh ${i}`);
          const currentBrush = new Brush(initialMeshes[i].geometry);
          currentBrush.applyMatrix4(initialMeshes[i].matrixWorld);

          try {
            resultBrush = csgEvaluator.evaluate(resultBrush, currentBrush, ADDITION);
          } catch (csgError) {
            console.error(`    Error during CSG Union in group ${group.colorName}:`, csgError);
            // Continue with what we have so far
            break;
          }
        }

        finalMesh = new THREE.Mesh(resultBrush.geometry, material);
        console.error(`  CSG Union complete for group ${group.colorName}.`);
      }

      scene.add(finalMesh);

      // Center and scale the mesh
      const box = new THREE.Box3().setFromObject(finalMesh);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());

      // Center the model in XY plane but keep Z at bottom
      finalMesh.position.x = -center.x;
      finalMesh.position.y = -center.y;
      finalMesh.position.z = -box.min.z;
      finalMesh.updateMatrixWorld();

      // Calculate scaling to preserve aspect ratio
      const maxDim = Math.max(size.x, size.y);
      if (maxDim > 1e-6 && desiredMaxSize > 0) {
        const scale = desiredMaxSize / maxDim;
        finalMesh.scale.set(scale, scale, scale);
        finalMesh.updateMatrixWorld();

        // Ensure the bottom is still at z=0 after scaling
        const scaledBox = new THREE.Box3().setFromObject(finalMesh);
        finalMesh.position.z = -scaledBox.min.z;
        finalMesh.updateMatrixWorld();
      }

      // Export to STL
      const exporter = new STLExporter();
      let currentBinaryOutput = binaryOutput; // Use a local variable that can be modified
      const options = { binary: currentBinaryOutput };
      let stlResult;

      try {
        stlResult = exporter.parse(scene, options);
        console.error(`  STL export successful for color ${group.colorName}`);

        // Check if the result is valid
        if (currentBinaryOutput && !(stlResult instanceof ArrayBuffer)) {
          console.error(`  Warning: Expected ArrayBuffer for binary STL but got ${typeof stlResult}. Falling back to ASCII.`);
          // Try again with ASCII
          currentBinaryOutput = false;
          stlResult = exporter.parse(scene, { binary: false });
        }

        // Verify we have content
        if ((currentBinaryOutput && stlResult.byteLength < 84) || // Binary STL header is 84 bytes
            (!currentBinaryOutput && stlResult.length < 100)) {   // ASCII STL should be at least 100 chars
          throw new Error(`STL result is too small: ${currentBinaryOutput ? stlResult.byteLength + ' bytes' : stlResult.length + ' chars'}`);
        }
      } catch (exportError) {
        console.error(`  Error during STL export for color ${group.colorName}:`, exportError);
        // Create a simple cube as fallback
        const cubeGeom = new THREE.BoxGeometry(10, 10, 10);
        const cubeMesh = new THREE.Mesh(cubeGeom, material);
        scene.clear(); // Remove previous objects
        scene.add(cubeMesh);
        console.error(`  Using fallback cube for color ${group.colorName}`);
        stlResult = exporter.parse(scene, { binary: false }); // Use ASCII for fallback
        currentBinaryOutput = false;
      }

      // Generate filename for this color group
      const colorFileName = `${modelId}_${group.colorName}.stl`;
      const outputPath = `${uploadDir}/${colorFileName}`;

      // Save STL file
      try {
        if (currentBinaryOutput) {
          // For binary STL, we need to handle the ArrayBuffer correctly
          const buffer = Buffer.from(stlResult);
          // Verify buffer has content
          if (buffer.length < 84) {
            console.error(`  Warning: Binary STL buffer is too small (${buffer.length} bytes). Creating fallback.`);
            // Create a simple ASCII STL cube as fallback
            const fallbackSTL = `solid ${group.colorName}\n` +
              `  facet normal 0 0 1\n    outer loop\n      vertex 0 0 0\n      vertex 10 0 0\n      vertex 10 10 0\n    endloop\n  endfacet\n` +
              `  facet normal 0 0 1\n    outer loop\n      vertex 0 0 0\n      vertex 10 10 0\n      vertex 0 10 0\n    endloop\n  endfacet\n` +
              `endsolid ${group.colorName}`;
            await fs.writeFile(outputPath, fallbackSTL);
            console.error(`  Saved fallback ASCII STL for color ${group.colorName} to ${outputPath} (${fallbackSTL.length} chars)`);
          } else {
            await fs.writeFile(outputPath, buffer);
            console.error(`  Saved binary STL for color ${group.colorName} to ${outputPath} (${buffer.length} bytes)`);
          }
        } else {
          // For ASCII STL, verify we have content
          if (stlResult.length < 100) {
            console.error(`  Warning: ASCII STL is too small (${stlResult.length} chars). Creating fallback.`);
            // Create a simple ASCII STL cube as fallback
            stlResult = `solid ${group.colorName}\n` +
              `  facet normal 0 0 1\n    outer loop\n      vertex 0 0 0\n      vertex 10 0 0\n      vertex 10 10 0\n    endloop\n  endfacet\n` +
              `  facet normal 0 0 1\n    outer loop\n      vertex 0 0 0\n      vertex 10 10 0\n      vertex 0 10 0\n    endloop\n  endfacet\n` +
              `endsolid ${group.colorName}`;
          }
          await fs.writeFile(outputPath, stlResult);
          console.error(`  Saved ASCII STL for color ${group.colorName} to ${outputPath} (${stlResult.length} chars)`);
        }

        // Add to results
        results.push({
          color: group.colorName,
          file: colorFileName
        });
      } catch (writeError) {
        console.error(`  Error saving STL file for color ${group.colorName}:`, writeError);
      }
    }

    // Make sure we actually generated files before writing JSON result
    if (results.length === 0) {
      console.error("FATAL: Processing finished, but no STL files were generated (likely due to geometry or CSG issues).");
      process.exit(1); // Exit with non-zero code
    }

    // Output the results as JSON to stdout
    const resultsJson = JSON.stringify({
      modelId: modelId,
      files: results
    });
    process.stdout.write(resultsJson); // Only write JSON if successful
    console.error(`Multi-color STL generation complete. Outputting JSON result (${results.length} files).`);

  } catch (error) {
    console.error('Fatal Error during STL generation:', error);
    process.exit(1);
  }
});

================
File: src/api/controllers/Controller.php
================
<?php
declare(strict_types=1);

namespace SVG25\Controllers;

interface Controller
{
    /**
     * Vrací odpověď jako JSON string
     */
    public function jsonResponse(array $data, int $statusCode = 200): string;
}

================
File: src/api/controllers/GenerateController.php
================
<?php
declare(strict_types=1);

namespace SVG25\Controllers;

use Exception;
use SVG25\Services\GeminiService;
use SVG25\Services\ImageProcessor;
use SVG25\Services\STLConverter;

class GenerateController implements Controller
{
    private GeminiService $geminiService;
    private ImageProcessor $imageProcessor;
    private STLConverter $stlConverter;

    public function __construct()
    {
        $this->geminiService = new GeminiService();
        $this->imageProcessor = new ImageProcessor();
        $this->stlConverter = new STLConverter();
    }

    /**
     * Zpracuje první krok - generování obrázku
     */
    public function generateImage(): string
    {
        try {
            $data = json_decode(file_get_contents('php://input'), true);
            if (!isset($data['prompt']) || empty($data['prompt'])) {
                throw new Exception('Missing or empty prompt', 400);
            }

            // Generování obrázku pomocí Gemini API
            $imagePath = $this->geminiService->generateImage($data['prompt']);
            $filename = basename($imagePath);

            // Vytvoření URL a relativní cesty pro přístup k obrázku
            $imageUrl = '/uploads/temp/' . $filename;
            $relativePath = 'src/public/uploads/temp/' . $filename;

            return $this->jsonResponse([
                'status' => 'success',
                'imageUrl' => $imageUrl,
                'imagePath' => $relativePath,
                'message' => 'Image successfully generated'
            ]);
        } catch (Exception $e) {
            // Log the error for debugging
            error_log("Error in generateImage: " . $e->getMessage());
            error_log("Stack trace: " . $e->getTraceAsString());

            // Check for specific error types to provide more helpful messages
            $errorMessage = $e->getMessage();
            $errorCode = $e->getCode() ?: 500;

            // Provide more user-friendly error messages for common issues
            if (strpos($errorMessage, 'API key') !== false) {
                $errorMessage = "Image generation failed. Please check the API key configuration.";
            } elseif (strpos($errorMessage, 'timeout') !== false || strpos($errorMessage, 'timed out') !== false) {
                $errorMessage = "Image generation timed out. Please try again with a simpler prompt.";
            }

            return $this->jsonResponse([
                'error' => $errorMessage,
                'code' => $errorCode,
                'details' => $e->getMessage() // Include the original error message for debugging
            ], $errorCode);
        }
    }

    /**
     * Zpracuje druhý krok - konverzi na STL
     */
    public function convertToStl(): string
    {
        try {
            $data = json_decode(file_get_contents('php://input'), true);
            if (!isset($data['imagePath']) || empty($data['imagePath'])) {
                throw new Exception('Missing or empty image path', 400);
            }

            // Konverze na SVG
            $absoluteImagePath = $data['imagePath'];
            $svgContent = $this->imageProcessor->convertToSVG($absoluteImagePath);

            // Získání výšky extruze z požadavku nebo použití výchozí hodnoty
            $extrusionHeight = isset($data['extrusionHeight']) ? (float)$data['extrusionHeight'] : 10.0;

            // Vytvoření nové instance STLConverter s požadovanou výškou extruze
            $binary = isset($data['stlFormat']) && $data['stlFormat'] === 'binary';
            // Získání kvality křivek z požadavku nebo použití výchozí hodnoty
            $curveSegments = isset($data['curveSegments']) ? (int)$data['curveSegments'] : 32; // Default 32 (Increased)
            // Získání cílové velikosti z požadavku nebo použití výchozí hodnoty
            $maxSize = isset($data['maxSize']) ? (float)$data['maxSize'] : 100.0; // Default 100mm
            $this->stlConverter = new STLConverter($extrusionHeight);

            // Konverze na STL
            $modelId = uniqid('model_');
            // Předání všech parametrů do convertToSTL
            $result = $this->stlConverter->convertToSTL($svgContent, $modelId, $binary, $curveSegments, $maxSize);

            // Získání modelId a informací o vygenerovaných souborech
            $modelId = $result['modelId'];
            $files = $result['files'];

            return $this->jsonResponse([
                'status' => 'success',
                'modelId' => $modelId,
                'files' => $files,
                'message' => 'Model successfully generated'
            ]);
        } catch (Exception $e) {
            // Log the error for debugging
            error_log("Error in convertToSTL: " . $e->getMessage());
            error_log("Stack trace: " . $e->getTraceAsString());

            // Check for specific error types to provide more helpful messages
            $errorMessage = $e->getMessage();
            $errorCode = $e->getCode() ?: 500;

            // Provide more user-friendly error messages for common issues
            if (strpos($errorMessage, 'Potrace') !== false) {
                $errorMessage = "SVG conversion failed. The image might be too complex or not suitable for conversion. Try a simpler image or adjust the contrast.";
            } elseif (strpos($errorMessage, 'No paths found') !== false) {
                $errorMessage = "The SVG doesn't contain any recognizable shapes. Try an image with clearer outlines or higher contrast.";
            } elseif (strpos($errorMessage, 'Node.js script failed') !== false) {
                $errorMessage = "3D model generation failed. The SVG might be too complex or contain unsupported elements.";
            }

            return $this->jsonResponse([
                'error' => $errorMessage,
                'code' => $errorCode,
                'details' => $e->getMessage() // Include the original error message for debugging
            ], $errorCode);
        }
    }

    /**
     * Zpracuje GET požadavek pro stažení vygenerovaného modelu
     * Pokud je k dispozici více barevných variant, vytvoří ZIP archiv
     */
    public function download(string $modelId): string
    {
        try {
            $baseDir = realpath(__DIR__ . '/../../../');
            $uploadDir = $baseDir . '/' . ($_ENV['UPLOAD_DIR'] ?? 'src/public/uploads');

            // Najít všechny STL soubory pro tento model
            $files = glob($uploadDir . '/' . $modelId . '_*.stl');

            // Pokud neexistují žádné soubory s prefixem, zkusit najít přesnou shodu
            if (empty($files)) {
                $exactFile = $uploadDir . '/' . $modelId . '.stl';
                if (file_exists($exactFile)) {
                    $files = [$exactFile];
                }
            }

            if (empty($files)) {
                throw new Exception('Model not found', 404);
            }

            // Pokud je jen jeden soubor, pošleme ho přímo
            if (count($files) === 1) {
                $filePath = $files[0];
                $fileName = basename($filePath);

                header('Content-Type: application/octet-stream');
                header('Content-Disposition: attachment; filename="' . $fileName . '"');
                header('Content-Length: ' . filesize($filePath));

                readfile($filePath);
                exit;
            }

            // Pokud je více souborů, vytvoříme ZIP archiv
            $zipFileName = $modelId . '.zip';
            $zipPath = $uploadDir . '/temp/' . $zipFileName;

            // Vytvoření ZIP archivu
            $zip = new \ZipArchive();
            if ($zip->open($zipPath, \ZipArchive::CREATE | \ZipArchive::OVERWRITE) !== true) {
                throw new Exception('Failed to create ZIP archive');
            }

            // Přidání všech STL souborů do archivu
            foreach ($files as $file) {
                $zip->addFile($file, basename($file));
            }

            $zip->close();

            // Odeslání ZIP archivu
            header('Content-Type: application/zip');
            header('Content-Disposition: attachment; filename="' . $zipFileName . '"');
            header('Content-Length: ' . filesize($zipPath));

            readfile($zipPath);

            // Odstranění dočasného ZIP souboru
            @unlink($zipPath);
            exit;
        } catch (Exception $e) {
            return $this->jsonResponse([
                'error' => $e->getMessage(),
                'code' => $e->getCode()
            ], $e->getCode() ?: 500);
        }
    }

    /**
     * Implementace Controller interface
     */
    public function jsonResponse(array $data, int $statusCode = 200): string
    {
        http_response_code($statusCode);
        return json_encode($data);
    }
}

================
File: src/api/models/Triangle3D.php
================
<?php
declare(strict_types=1);

namespace SVG25\Models;

class Triangle3D
{
    /**
     * @var Vector3D[] $vertices
     */
    public array $vertices;

    public function __construct(Vector3D $v1, Vector3D $v2, Vector3D $v3)
    {
        $this->vertices = [$v1, $v2, $v3];
    }

    /**
     * Calculate the normal vector for the triangle
     */
    public function calculateNormal(): Vector3D
    {
        // Calculate two edges of the triangle
        $edge1 = $this->vertices[1]->subtract($this->vertices[0]);
        $edge2 = $this->vertices[2]->subtract($this->vertices[0]);
        
        // The normal is the cross product of the two edges
        $normal = $edge1->cross($edge2);
        
        // Check for degenerate triangle resulting in NaN values
        if (is_nan($normal->x) || is_nan($normal->y) || is_nan($normal->z)) {
            return new Vector3D(0, 0, 1); // Default normal if calculation fails
        }
        
        // Return the normal (not normalized)
        return $normal;
    }

    /**
     * Calculate the area of the triangle
     */
    public function area(): float
    {
        $normal = $this->calculateNormal();
        return 0.5 * $normal->length();
    }

    /**
     * Check if the triangle is degenerate (has zero area)
     */
    public function isDegenerate(float $epsilon = 0.0001): bool
    {
        return $this->area() < $epsilon;
    }

    /**
     * Calculate the center/centroid of the triangle
     */
    public function centroid(): Vector3D
    {
        return new Vector3D(
            ($this->vertices[0]->x + $this->vertices[1]->x + $this->vertices[2]->x) / 3,
            ($this->vertices[0]->y + $this->vertices[1]->y + $this->vertices[2]->y) / 3,
            ($this->vertices[0]->z + $this->vertices[1]->z + $this->vertices[2]->z) / 3
        );
    }
}

================
File: src/api/models/Vector3D.php
================
<?php
declare(strict_types=1);

namespace SVG25\Models;

class Vector3D
{
    public float $x;
    public float $y;
    public float $z;

    public function __construct(float $x, float $y, float $z)
    {
        $this->x = $x;
        $this->y = $y;
        $this->z = $z;
    }

    /**
     * Calculate distance to another vector
     */
    public function distanceTo(Vector3D $other): float
    {
        $dx = $this->x - $other->x;
        $dy = $this->y - $other->y;
        $dz = $this->z - $other->z;
        return sqrt($dx * $dx + $dy * $dy + $dz * $dz);
    }

    /**
     * Calculate squared length of the vector
     */
    public function lengthSq(): float
    {
        return $this->x * $this->x + $this->y * $this->y + $this->z * $this->z;
    }

    /**
     * Calculate length of the vector
     */
    public function length(): float
    {
        return sqrt($this->lengthSq());
    }

    /**
     * Add another vector
     */
    public function add(Vector3D $other): Vector3D
    {
        return new Vector3D(
            $this->x + $other->x,
            $this->y + $other->y,
            $this->z + $other->z
        );
    }

    /**
     * Subtract another vector
     */
    public function subtract(Vector3D $other): Vector3D
    {
        return new Vector3D(
            $this->x - $other->x,
            $this->y - $other->y,
            $this->z - $other->z
        );
    }

    /**
     * Cross product with another vector
     */
    public function cross(Vector3D $other): Vector3D
    {
        return new Vector3D(
            $this->y * $other->z - $this->z * $other->y,
            $this->z * $other->x - $this->x * $other->z,
            $this->x * $other->y - $this->y * $other->x
        );
    }

    /**
     * Dot product with another vector
     */
    public function dot(Vector3D $other): float
    {
        return $this->x * $other->x + $this->y * $other->y + $this->z * $other->z;
    }

    /**
     * Scale the vector by a factor
     */
    public function scale(float $factor): Vector3D
    {
        return new Vector3D(
            $this->x * $factor,
            $this->y * $factor,
            $this->z * $factor
        );
    }

    /**
     * Normalize the vector (makes it unit length)
     */
    public function normalize(): Vector3D
    {
        $length = $this->length();
        if ($length < 0.00001) {
            return new Vector3D(0, 0, 0);
        }
        
        return $this->scale(1.0 / $length);
    }
}

================
File: src/api/services/GeminiService.php
================
<?php
declare(strict_types=1);

namespace SVG25\Services;

use Exception;
use GuzzleHttp\Client;
use GuzzleHttp\Exception\GuzzleException;

class GeminiService
{
    private Client $client;
    private string $apiKey;
    private string $baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
    private string $model = 'gemini-2.0-flash-exp-image-generation';
    private string $uploadUrl = 'https://generativelanguage.googleapis.com/upload/v1beta/files';

    public function __construct()
    {
        $this->apiKey = $_ENV['GEMINI_API_KEY'] ?? throw new Exception('Missing Gemini API key');
        $this->client = new Client([
            'timeout' => 60,
        ]);
    }

    /**
     * Uploads an image file to Google's generative AI service
     * 
     * @param string $filePath Path to the image file
     * @param string $mimeType MIME type of the image file
     * @return string The file URI for reference in subsequent API calls
     * @throws Exception
     */
    public function uploadFile(string $filePath, string $mimeType = 'image/png'): string
    {
        if (!file_exists($filePath)) {
            throw new Exception("File not found: {$filePath}");
        }

        $fileContent = file_get_contents($filePath);
        $numBytes = strlen($fileContent);
        $displayName = basename($filePath);

        try {
            $response = $this->client->post("{$this->uploadUrl}?key={$this->apiKey}", [
                'headers' => [
                    'X-Goog-Upload-Command' => 'start, upload, finalize',
                    'X-Goog-Upload-Header-Content-Length' => $numBytes,
                    'X-Goog-Upload-Header-Content-Type' => $mimeType,
                    'Content-Type' => 'application/json',
                ],
                'json' => [
                    'file' => [
                        'display_name' => $displayName
                    ]
                ],
                'body' => $fileContent
            ]);

            $result = json_decode($response->getBody()->getContents(), true);
            
            if (!isset($result['file']['uri'])) {
                throw new Exception('No file URI in response');
            }

            return $result['file']['uri'];
        } catch (GuzzleException $e) {
            throw new Exception('Failed to upload file: ' . $e->getMessage(), $e->getCode());
        }
    }

    /**
     * Generates an image from text prompt using Gemini API
     * Can optionally use a reference image for the generation
     * 
     * @param string $prompt The text prompt for image generation
     * @param string|null $referenceImagePath Optional path to a reference image
     * @return string Path to the generated image
     * @throws Exception
     */
    public function generateImage(string $prompt, ?string $referenceImagePath = null): string
    {
        try {
            $contents = [];
            
            // First user message with prompt
            $contents[] = [
                'role' => 'user',
                'parts' => [
                    ['text' => 'Create a minimalist black and white lineart illustration of '.$prompt.', contained within a perfect circle with thick border. Use clean continuous lines suitable for 3D printing as wall art with bold outlines, negative space, and the same graphic style as the reference image - high contrast, simplified shapes, and subtle background elements to create depth. The $prompt should be the main focus in the center of the circular composition.']
                ]
            ];
            
            // Add reference image if provided
            if ($referenceImagePath) {
                $fileUri = $this->uploadFile($referenceImagePath);
                
                // Add model response with the reference image
                $contents[] = [
                    'role' => 'model',
                    'parts' => [
                        [
                            'fileData' => [
                                'fileUri' => $fileUri,
                                'mimeType' => 'image/png'
                            ]
                        ]
                    ]
                ];
                
                // Add second user message (can be empty or additional instructions)
                $contents[] = [
                    'role' => 'user',
                    'parts' => [
                        ['text' => '']
                    ]
                ];
            }
            
            $response = $this->client->post("{$this->baseUrl}/models/{$this->model}:generateContent", [
                'query' => ['key' => $this->apiKey],
                'json' => [
                    'contents' => $contents,
                    'generationConfig' => [
                        'temperature' => 1,
                        'topK' => 40,
                        'topP' => 0.95,
                        'maxOutputTokens' => 8192,
                        'responseMimeType' => 'text/plain',
                        'responseModalities' => [
                            'image',
                            'text'
                        ]
                    ]
                ]
            ]);
            
            $result = json_decode($response->getBody()->getContents(), true);
            
            if (!isset($result['candidates'][0]['content']['parts'][0]['inlineData']['data'])) {
                throw new Exception('No image data in response');
            }
            
            // Decode Base64 image
            $imageData = base64_decode($result['candidates'][0]['content']['parts'][0]['inlineData']['data']);
            if ($imageData === false) {
                throw new Exception('Invalid image data received');
            }
            
            // Save temporary file
            $tempDir = realpath(__DIR__ . '/../../../') . '/' . $_ENV['UPLOAD_DIR'] . '/temp';
            if (!is_dir($tempDir)) {
                mkdir($tempDir, 0755, true);
            }
            
            $tempFile = $tempDir . '/' . uniqid('gemini_') . '.png';
            if (file_put_contents($tempFile, $imageData) === false) {
                throw new Exception('Failed to save temporary image');
            }
            
            return $tempFile;
        } catch (GuzzleException $e) {
            throw new Exception('Failed to generate image: ' . $e->getMessage(), $e->getCode());
        }
    }
}

================
File: src/api/services/ImageProcessor.php
================
<?php
declare(strict_types=1);

namespace SVG25\Services;

use Exception;

class ImageProcessor
{
    private string $uploadDir;
    private int $maxImageSize;

    public function __construct()
    {
        $baseDir = realpath(__DIR__ . '/../../../');
        $this->uploadDir = $baseDir . '/' . ($_ENV['UPLOAD_DIR'] ?? 'src/public/uploads');
        $this->maxImageSize = (int)($_ENV['MAX_IMAGE_SIZE'] ?? 5242880); // 5MB default
    }

    /**
     * Konvertuje PNG obrázek na SVG pomocí Imagick a Potrace
     *
     * @throws Exception Pokud konverze selže
     */
    public function convertToSVG(string $imagePath): string
    {
        $debug = true; // Enable debugging
        $tempFiles = []; // Track temporary files for cleanup

        try {


            // Převod relativní cesty na absolutní
            // Check if the path is already absolute
            if (file_exists($imagePath)) {
                $absolutePath = $imagePath;
            } else {
                // Try to resolve as a relative path
                $baseDir = realpath(__DIR__ . '/../../../');
                $absolutePath = $baseDir . '/' . $imagePath;

                // Remove any double slashes in the path
                $absolutePath = preg_replace('#/+#', '/', $absolutePath);

                // Kontrola existence souboru
                if (!file_exists($absolutePath)) {
                    throw new Exception("Image file not found: {$absolutePath}");
                }
            }

            if ($debug) error_log("Using image file: {$absolutePath}");

            // Kontrola velikosti souboru
            $fileSize = filesize($absolutePath);
            if ($fileSize === false || $fileSize > $this->maxImageSize) {
                throw new Exception("Image file too large or unreadable: {$absolutePath}, size: {$fileSize}");
            }
            // Načtení obrázku pomocí Imagick
            $imagick = new \Imagick($absolutePath);

            // Resize image if it's too large (for better processing)
            $geometry = $imagick->getImageGeometry();
            $maxDimension = max($geometry['width'], $geometry['height']);
            if ($maxDimension > 1200) {
                $ratio = 1200 / $maxDimension;
                $imagick->resizeImage(
                    (int)($geometry['width'] * $ratio),
                    (int)($geometry['height'] * $ratio),
                    \Imagick::FILTER_LANCZOS,
                    1
                );
            }

            if ($debug) error_log("Image resized to: {$imagick->getImageWidth()}x{$imagick->getImageHeight()}");

            // Enhanced preprocessing for better edge detection
            // First, ensure we're working with RGB
            $imagick->setImageColorspace(\Imagick::COLORSPACE_RGB);

            // Apply preprocessing for better edge detection
            $imagick->despeckleImage(); // Remove noise
            $imagick->enhanceImage(); // Enhance local contrast

            // Apply additional preprocessing
            $imagick->unsharpMaskImage(0, 1.0, 1.0, 0.05); // Unsharp mask for better edges

            // Převod na černobílý obrázek pro lepší vektorizaci
            $imagick->setImageColorspace(\Imagick::COLORSPACE_GRAY);
            $imagick->setImageType(\Imagick::IMGTYPE_GRAYSCALE);
            $imagick->modulateImage(100, 0, 100);

            // Úprava kontrastu pro lepší detekci hran
            $imagick->normalizeImage();
            $imagick->contrastImage(true);
            $imagick->sharpenImage(0, 1.0); // Sharpen edges

            // Apply threshold to create a true black and white image
            // Get quantum range with fallback for older Imagick versions
            $quantumRange = $imagick->getQuantumRange();
            $maxQuantum = isset($quantumRange[1]) ? $quantumRange[1] : 65535; // Default to 16-bit max if not available
            $imagick->thresholdImage(0.5 * $maxQuantum);

            if ($debug) error_log("Image preprocessing complete");

            // Uložení dočasného PBM souboru pro Potrace
            $pbmFile = $this->uploadDir . '/temp/' . uniqid('trace_') . '.pbm';
            $imagick->setImageFormat('pbm');
            $imagick->writeImage($pbmFile);

            if ($debug) error_log("PBM file written to: {$pbmFile}");

            // Add pbmFile to temp files list for cleanup
            $tempFiles[] = $pbmFile;

            // Ensure temp directory exists
            $tempDir = $this->uploadDir . '/temp';
            if (!is_dir($tempDir)) {
                if (!mkdir($tempDir, 0755, true)) {
                    throw new Exception("Failed to create temp directory: {$tempDir}");
                }
            }

            // Použití Potrace pro konverzi na SVG s vylepšenými parametry
            $svgFile = $this->uploadDir . '/temp/' . uniqid('vector_') . '.svg';

            // Verify the PBM file exists and has content
            if (!file_exists($pbmFile)) {
                throw new Exception("PBM file not found: {$pbmFile}");
            }

            $pbmFileSize = filesize($pbmFile);
            if ($pbmFileSize === 0) {
                throw new Exception("PBM file is empty: {$pbmFile}");
            }

            if ($debug) error_log("PBM file size: {$pbmFileSize} bytes");

            // Try with basic parameters that work with most Potrace versions
            $command = sprintf(
                'potrace %s -s -o %s -t 2 -a 1',
                escapeshellarg($pbmFile),
                escapeshellarg($svgFile)
            );

            // Potrace parameters explanation:
            // -s: Output SVG format
            // -o: Output file
            // -t 2: Suppress speckles of up to this size (turdsize)
            // -a 1: Corner threshold parameter (alphamax)
            // Using short options for better compatibility with different Potrace versions

            // Check if potrace is installed
            exec('which potrace 2>&1', $whichOutput, $whichReturnVar);
            if ($whichReturnVar !== 0) {
                if ($debug) {
                    error_log("Potrace not found in PATH. Output: " . implode("\n", $whichOutput));
                }

                // Try with absolute path if available
                $potracePaths = [
                    '/usr/bin/potrace',
                    '/usr/local/bin/potrace',
                    '/opt/homebrew/bin/potrace',
                    '/opt/local/bin/potrace'
                ];

                $potraceFound = false;
                foreach ($potracePaths as $potracePath) {
                    if (file_exists($potracePath) && is_executable($potracePath)) {
                        if ($debug) error_log("Found potrace at: {$potracePath}");
                        $command = sprintf(
                            '%s %s -s -o %s -t 2 -a 1',
                            escapeshellarg($potracePath),
                            escapeshellarg($pbmFile),
                            escapeshellarg($svgFile)
                        );
                        $potraceFound = true;
                        break;
                    }
                }

                if (!$potraceFound) {
                    throw new Exception('Potrace is not installed or not in PATH. Please install potrace: https://potrace.sourceforge.net/');
                }
            }

            if ($debug) error_log("Executing command: {$command}");

            // Execute with full output capture
            $descriptorspec = [
                0 => ["pipe", "r"],  // stdin
                1 => ["pipe", "w"],  // stdout
                2 => ["pipe", "w"]   // stderr
            ];

            $process = proc_open($command, $descriptorspec, $pipes);
            if (!is_resource($process)) {
                throw new Exception("Failed to execute potrace command");
            }

            // Close stdin as we don't need to write anything
            fclose($pipes[0]);

            // Read stdout and stderr
            $stdout = stream_get_contents($pipes[1]);
            $stderr = stream_get_contents($pipes[2]);
            fclose($pipes[1]);
            fclose($pipes[2]);

            // Get the exit code
            $returnVar = proc_close($process);

            // Add svgFile to temp files list for cleanup
            $tempFiles[] = $svgFile;

            // Kontrola, zda se konverze povedla
            if ($returnVar !== 0) {
                if ($debug) {
                    error_log("Potrace command failed with return code: {$returnVar}");
                    error_log("Stdout: {$stdout}");
                    error_log("Stderr: {$stderr}");

                    // Save the problematic PBM file for inspection
                    $debugPbmFile = $this->uploadDir . '/temp/debug_' . basename($pbmFile);
                    copy($pbmFile, $debugPbmFile);
                    error_log("Saved problematic PBM file to: {$debugPbmFile}");
                }
                throw new Exception('SVG conversion failed: Potrace returned error code ' . $returnVar . '. Error: ' . $stderr);
            }

            if ($debug) error_log("Potrace command executed successfully");

            // Načtení a vyčištění SVG
            $svgContent = file_get_contents($svgFile);
            if ($svgContent === false) {
                throw new Exception('Failed to read generated SVG');
            }

            // Check if the SVG contains any path elements
            if (!preg_match('/<path[^>]*>/', $svgContent) && !preg_match('/<polygon[^>]*>/', $svgContent)) {
                if ($debug) error_log("SVG does not contain any path or polygon elements. Adding a fallback path.");

                // Extract width and height
                $width = 100;
                $height = 100;
                if (preg_match('/width="([^"]*pt)"/', $svgContent, $widthMatch)) {
                    $width = (float)str_replace('pt', '', $widthMatch[1]);
                }
                if (preg_match('/height="([^"]*pt)"/', $svgContent, $heightMatch)) {
                    $height = (float)str_replace('pt', '', $heightMatch[1]);
                }

                // Add a simple rectangle path
                $fallbackPath = "<path d=\"M10,10 L" . ($width-10) . ",10 L" . ($width-10) . "," . ($height-10) . " L10," . ($height-10) . " Z\" fill=\"black\"/>";
                $svgContent = str_replace('</svg>', $fallbackPath . '</svg>', $svgContent);

                if ($debug) error_log("Added fallback path to SVG: $fallbackPath");
            }

            if ($debug) {
                error_log("SVG file generated successfully, size: " . strlen($svgContent) . " bytes");
                error_log("SVG content preview: " . substr($svgContent, 0, 200) . "...");
            }

            // Vyčištění dočasných souborů
            foreach ($tempFiles as $file) {
                if (file_exists($file)) {
                    if (!unlink($file)) {
                        if ($debug) error_log("Warning: Failed to delete temporary file: {$file}");
                    }
                }
            }

            // Delete the original image file if it exists
            if (file_exists($absolutePath)) {
                if (!unlink($absolutePath)) {
                    if ($debug) error_log("Warning: Failed to delete original image file: {$absolutePath}");
                }
            }

            // Process and return the cleaned SVG content
            $cleanedSvg = $this->cleanupSVG($svgContent);
            if ($debug) error_log("SVG cleanup complete, final size: " . strlen($cleanedSvg) . " bytes");
            return $cleanedSvg;

        } catch (\Exception $e) { // Catch all exceptions, including ImagickException
            if ($debug) {
                error_log("Imagick exception: " . $e->getMessage());
                error_log($e->getTraceAsString());
            }
            throw new Exception('Image processing failed: ' . $e->getMessage());
        } catch (Exception $e) {
            if ($debug) {
                error_log("Exception during SVG conversion: " . $e->getMessage());
                error_log($e->getTraceAsString());
            }
            throw $e;
        } finally {
            // Ensure all temporary files are cleaned up even if an exception occurs
            foreach ($tempFiles as $file) {
                if (file_exists($file)) {
                    @unlink($file);
                }
            }
        }
    }

    /**
     * Vyčistí a optimalizuje SVG kód
     */
    private function cleanupSVG(string $svg): string
    {
        $debug = isset($_ENV['DEBUG']) && $_ENV['DEBUG'] === 'true';
        // Odstranění komentářů a metadata
        $svg = preg_replace('/<!--.*?-->/s', '', $svg);
        $svg = preg_replace('/<\?xml.*?\?>/s', '', $svg);

        // Preserve important attributes but remove unnecessary ones
        // Don't remove fill-rule="evenodd" as it's important for proper rendering
        $svg = preg_replace('/\s+stroke="none"/i', '', $svg);

        // Add xmlns attribute if missing
        if (!strpos($svg, 'xmlns=')) {
            $svg = str_replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"', $svg);
        }

        // Extract width and height from SVG if available
        $width = null;
        $height = null;
        // Use more robust check for captured group
        if (preg_match('/width="([^"]+)"/', $svg, $widthMatch) && isset($widthMatch[1])) {
            $width = str_replace('pt', '', $widthMatch[1]);
        }
        if (preg_match('/height="([^"]+)"/', $svg, $heightMatch) && isset($heightMatch[1])) {
            $height = str_replace('pt', '', $heightMatch[1]);
        }

        // Přidání viewBox pokud chybí
        if (!strpos($svg, 'viewBox')) {
            // Use !is_null check and ensure values are numeric
            if (!is_null($width) && !is_null($height) && is_numeric($width) && is_numeric($height)) {
                // Use actual dimensions for viewBox
                $svg = preg_replace('/<svg/', '<svg viewBox="0 0 ' . $width . ' ' . $height . '"', $svg, 1); // Use limit 1
            } else {
                // Fallback to default dimensions
                $svg = preg_replace('/<svg/', '<svg viewBox="0 0 100 100"', $svg, 1); // Use limit 1
            }
        }

        // Convert any g elements with paths to direct paths if needed
        if (preg_match('/<g[^>]*>/', $svg) && !preg_match('/<path[^>]*>/', $svg)) {
            // Extract paths from g elements
            preg_match_all('/<g[^>]*>(.*?)<\/g>/s', $svg, $matches);
            if (!empty($matches[1])) {
                foreach ($matches[1] as $gContent) {
                    // Look for path-like content
                    if (preg_match('/d="([^"]+)"/', $gContent, $pathMatch)) {
                        $pathD = $pathMatch[1];
                        $newPath = "<path d=\"$pathD\" fill=\"black\"/>";
                        // Add the path before the closing </svg>
                        $svg = str_replace('</svg>', $newPath . '</svg>', $svg);
                    }
                }
            }
        }

        // Convert any polygon elements to paths if needed
        if (preg_match('/<polygon[^>]*>/', $svg) && !preg_match('/<path[^>]*>/', $svg)) {
            preg_match_all('/<polygon[^>]*points="([^"]*)"[^>]*\/?>/s', $svg, $matches);
            if (!empty($matches[1])) {
                foreach ($matches[1] as $points) {
                    $pointsArray = preg_split('/\s+|,/', trim($points));
                    if (count($pointsArray) >= 4) { // Need at least 2 points (4 coordinates)
                        $pathD = "M{$pointsArray[0]},{$pointsArray[1]}";
                        for ($i = 2; $i < count($pointsArray); $i += 2) {
                            if ($i + 1 < count($pointsArray)) {
                                $pathD .= " L{$pointsArray[$i]},{$pointsArray[$i+1]}";
                            }
                        }
                        $pathD .= ' Z'; // Close the path
                        $newPath = "<path d=\"$pathD\" fill=\"black\"/>";
                        // Add the path before the closing </svg>
                        $svg = str_replace('</svg>', $newPath . '</svg>', $svg);
                    }
                }
            }
        }

        // Ensure all paths have a fill attribute if missing
        $svg = preg_replace_callback('/<path([^>]*)>/', function($matches) {
            $attributes = $matches[1];
            if (!strpos($attributes, 'fill=')) {
                return '<path' . $attributes . ' fill="black">';
            }
            return $matches[0];
        }, $svg);

        // Add a fallback path if no paths are present
        if (!preg_match('/<path[^>]*>/', $svg)) {
            // Extract width and height again (in case they were updated)
            $width = 100;
            $height = 100;
            if (preg_match('/width="([^"]+)"/', $svg, $widthMatch) && isset($widthMatch[1])) {
                $width = str_replace('pt', '', $widthMatch[1]);
                // Ensure width is numeric
                if (!is_numeric($width)) {
                    $width = 100;
                }
            }
            if (preg_match('/height="([^"]+)"/', $svg, $heightMatch) && isset($heightMatch[1])) {
                $height = str_replace('pt', '', $heightMatch[1]);
                // Ensure height is numeric
                if (!is_numeric($height)) {
                    $height = 100;
                }
            }

            // Add a simple rectangle path
            $fallbackPath = "<path d=\"M10,10 L" . ($width-10) . ",10 L" . ($width-10) . "," . ($height-10) . " L10," . ($height-10) . " Z\" fill=\"black\"/>";
            $svg = str_replace('</svg>', $fallbackPath . '</svg>', $svg);

            if ($debug) error_log("Added fallback rectangle path to SVG: {$fallbackPath}");
        }

        return $svg;
    }
}

================
File: src/api/services/STLConverter.php
================
<?php
declare(strict_types=1);

namespace SVG25\Services;

use Exception;
use SVG25\Models\Vector3D; // Keep for potential future use if needed elsewhere, but not for core STL generation
use SVG25\Models\Triangle3D; // Keep for potential future use if needed elsewhere, but not for core STL generation

class STLConverter
{
    private float $extrusionHeight;
    private string $uploadDir;
    private bool $debug = false;
    private string $nodePath; // Path to Node.js executable
    private string $scriptPath; // Path to the triangulate.js script

    public function __construct(float $extrusionHeight = null)
    {
        $this->extrusionHeight = $extrusionHeight ?? (float)($_ENV['DEFAULT_EXTRUSION_HEIGHT'] ?? 10.0);
        $baseDir = realpath(__DIR__ . '/../../../');
        $this->uploadDir = $baseDir . '/' . ($_ENV['UPLOAD_DIR'] ?? 'src/public/uploads');

        // Attempt to find Node.js executable
        $this->nodePath = $this->findNodeExecutable() ?? 'node'; // Default to 'node' if not found

        // Path to the Node.js script relative to this file's directory
        $this->scriptPath = realpath(__DIR__ . '/../../../scripts/triangulate.js');

        if ($this->scriptPath === false || !is_file($this->scriptPath)) {
             throw new Exception("Node.js script not found at expected location: " . __DIR__ . '/../../../scripts/triangulate.js');
        }
    }

    /**
     * Enable debug mode
     */
    public function enableDebug(): void
    {
        $this->debug = true;
    }

    /**
     * Convert SVG content to STL files using an external Node.js script.
     * This version supports multi-color STL generation, creating separate files for each color.
     *
     * @param string $svgContent SVG content to convert.
     * @param string $modelId Model identifier used for the filename.
     * @param bool $binary Whether to generate binary STL (true) or ASCII STL (false).
     * @param int $curveSegments Number of segments for approximating curves. Higher values mean better quality but larger files.
     * @param float $maxSize Target maximum size (in mm) for the longest dimension (X or Y) of the model base.
     * @return array Information about the generated STL files, including the base modelId and file paths.
     * @throws Exception If conversion fails.
     */
    public function convertToSTL(string $svgContent, string $modelId, bool $binary = true, int $curveSegments = 12, float $maxSize = 100.0): array
    {
        // Enable debug mode for troubleshooting
        $this->debug = true;

        try {
            // Log the SVG content for debugging
            if ($this->debug) {
                error_log("SVG content length: " . strlen($svgContent));
                error_log("SVG content preview: " . substr($svgContent, 0, 200) . "...");
            }
            // 1. Create necessary directories
            if (!is_dir($this->uploadDir)) {
                if (!mkdir($this->uploadDir, 0755, true)) {
                    throw new Exception("Failed to create upload directory: {$this->uploadDir}");
                }
            }
            if (!is_writable($this->uploadDir)) {
                throw new Exception("Upload directory is not writable: {$this->uploadDir}");
            }

            if ($this->debug) {
                error_log("Starting SVG to STL conversion via Node.js for model: " . $modelId);
                error_log("Node path: " . $this->nodePath);
                error_log("Script path: " . $this->scriptPath);
                error_log("Upload directory: " . $this->uploadDir);
                error_log("Parameters: binary={$binary}, curveSegments={$curveSegments}, extrusionHeight={$this->extrusionHeight}, maxSize={$maxSize}");
            }

            // 2. Prepare data for Node.js script
            $inputData = json_encode([
                'svgContent' => $svgContent,
                'extrusionDepth' => $this->extrusionHeight,
                'curveSegments' => $curveSegments,
                'binary' => $binary,
                'maxSize' => $maxSize,
                'modelId' => $modelId,
                'uploadDir' => $this->uploadDir,
            ]);

            if ($inputData === false) {
                throw new Exception("Failed to encode input data as JSON: " . json_last_error_msg());
            }

            // 3. Execute Node.js script directly, without shell redirection
            $descriptorspec = [
               0 => ["pipe", "r"],  // stdin
               1 => ["pipe", "w"],  // stdout - We will read from this
               2 => ["pipe", "w"]   // stderr
            ];

            // Ensure paths are safe for shell execution, though direct execution is safer
            $nodePathEscaped = escapeshellarg($this->nodePath);
            $scriptPathEscaped = escapeshellarg($this->scriptPath);

            // Command is just the node executable and the script path
            $command = $nodePathEscaped . " " . $scriptPathEscaped;

            // Create temp directory if it doesn't exist
            $tempDir = dirname($this->uploadDir) . '/temp';
            if (!is_dir($tempDir)) {
                if (!mkdir($tempDir, 0755, true)) {
                    throw new Exception("Failed to create temp directory: {$tempDir}");
                }
            }

            if ($this->debug) {
                error_log("Executing command: " . $command);
                error_log("Input data size: " . strlen($inputData) . " bytes");
            }

            // Run the process in the script's directory
            $process = proc_open($command, $descriptorspec, $pipes, dirname($this->scriptPath));

            if (!is_resource($process)) {
                throw new Exception("Failed to execute Node.js script command via proc_open.");
            }

            // Send JSON data to stdin
            $bytesWritten = fwrite($pipes[0], $inputData);
            // Immediately close stdin after writing to signal Node.js we are done sending input
            fclose($pipes[0]);

            if ($bytesWritten === false || $bytesWritten < strlen($inputData)) {
                 if ($this->debug) error_log("Failed to write complete input data to Node.js stdin.");
                 // Attempt to close other pipes and process before throwing
                 @fclose($pipes[1]); @fclose($pipes[2]); @proc_close($process);
                 throw new Exception("Failed to write input data to Node.js process.");
            }
            // Stdin is now closed

            // *** Read JSON result from stdout IN CHUNKS ***
            $resultJson = '';
            stream_set_blocking($pipes[1], true); // Ensure blocking read
            while (!feof($pipes[1])) {
                // Read up to 8KB at a time
                $chunk = fread($pipes[1], 8192);
                if ($chunk === false) {
                    // Error reading the pipe
                    $read_error = error_get_last(); // Get more details about the read error
                    if ($this->debug) error_log("Error reading chunk from Node.js stdout pipe: " . ($read_error['message'] ?? 'Unknown error'));
                    @fclose($pipes[1]); @fclose($pipes[2]); @proc_close($process);
                    throw new Exception("Error reading JSON data stream from Node.js process: " . ($read_error['message'] ?? 'Unknown error'));
                }
                // Append the chunk to the content
                $resultJson .= $chunk;
            }
            fclose($pipes[1]); // Close stdout pipe ONLY AFTER the loop finishes (feof is true)
            // *** End reading in chunks ***

            // Read errors from stderr
            $errors = stream_get_contents($pipes[2]); // stderr is usually small enough
            fclose($pipes[2]);

            // Close the process and get the exit code
            $return_value = proc_close($process);

            if ($this->debug) {
                // Log stderr first, it might contain crucial info
                error_log("Node.js stderr:\n" . ($errors ?: '(empty)'));
                error_log("Node.js exit code: " . $return_value);
                error_log("Raw Node.js stdout:\n" . ($resultJson ?: '(empty)')); // Log raw stdout
                error_log("Bytes read from Node.js stdout: " . strlen($resultJson));

                // Save stderr to a file for debugging
                if (!empty($errors)) {
                    // Ensure temp dir exists for error logs too
                    $tempDir = dirname($this->uploadDir) . '/temp';
                    if (!is_dir($tempDir)) { @mkdir($tempDir, 0755, true); }
                    $errorLogFile = $tempDir . '/node_error_' . uniqid() . '.log';
                    @file_put_contents($errorLogFile, $errors);
                    error_log("Node.js stderr saved to: {$errorLogFile}");
                }
            }

            // *** NEW: Improved Check ***
            // Check process exit code FIRST
            if ($return_value !== 0) {
                throw new Exception("Node.js script failed with exit code {$return_value}. Check stderr logs for details. Errors: " . $errors);
            }

            // Check if stdout is empty
            if (empty($resultJson)) {
                throw new Exception("Node.js script finished successfully (exit code 0) but produced no output (expected JSON result). Check stderr logs. Errors: " . $errors);
            }
            // *** END NEW CHECK ***

            // Parse the JSON result
            $result = json_decode($resultJson, true);
            if (json_last_error() !== JSON_ERROR_NONE) {
                throw new Exception("Failed to parse JSON result from Node.js script: " . json_last_error_msg() . ". Raw output: " . $resultJson);
            }

            // Verify the result structure
            if (!isset($result['modelId']) || !isset($result['files']) || !is_array($result['files'])) {
                throw new Exception("Invalid JSON result structure from Node.js script. Expected 'modelId' and 'files' array. Received: " . substr($resultJson, 0, 500) . '...');
            }

            // Check if the files array is empty even if JSON is valid
            $fileCount = count($result['files']);
            if ($fileCount === 0) {
                throw new Exception("Node.js script returned a valid JSON structure, but the 'files' array is empty, indicating no STL files were generated. Check stderr logs. Errors: " . $errors);
            }

            // Verify that all files exist
            $missingFiles = [];
            $fileDetails = [];
            $baseDir = realpath(__DIR__ . '/../../../');
            $baseDir = rtrim(str_replace('\\', '/', $baseDir), '/') . '/';

            foreach ($result['files'] as $fileInfo) {
                $filePath = $this->uploadDir . '/' . $fileInfo['file'];
                if (!file_exists($filePath)) {
                    $missingFiles[] = $fileInfo['file'];
                    continue;
                }

                // Verify the STL file has valid content
                $stlFileSize = filesize($filePath);
                if ($stlFileSize < 100) { // Minimum size for a valid STL file
                    if ($this->debug) error_log("Generated STL file is too small: {$stlFileSize} bytes");
                    $missingFiles[] = $fileInfo['file'] . " (too small: {$stlFileSize} bytes)";
                    continue;
                }

                // Get the relative path
                $stlPathNormalized = str_replace('\\', '/', $filePath);
                if (strpos($stlPathNormalized, $baseDir) === 0) {
                    $relativePath = substr($stlPathNormalized, strlen($baseDir));
                } else {
                    $relativePath = basename($filePath); // Just the filename as fallback
                    if($this->debug) error_log("Warning: Could not create relative path correctly for {$filePath}. Using basename.");
                }

                // Add to file details
                $fileDetails[] = [
                    'color' => $fileInfo['color'],
                    'file' => $fileInfo['file'],
                    'path' => $relativePath,
                    'size' => $stlFileSize
                ];
            }

            if (!empty($missingFiles)) {
                throw new Exception("Some generated STL files are missing or invalid: " . implode(', ', $missingFiles));
            }

            if ($this->debug) {
                error_log("STL conversion successful. Generated {$fileCount} color-separated STL files.");
            }

            // Return information about the generated files
            return [
                'modelId' => $result['modelId'],
                'files' => $fileDetails
            ];

        } catch (Exception $e) {
            if ($this->debug) {
                error_log("STL conversion failed: " . $e->getMessage());
                error_log($e->getTraceAsString());

                // Save detailed error information to a file
                $errorFile = $this->uploadDir . '/temp/error_' . uniqid() . '.log';
                $errorDetails = "Error: " . $e->getMessage() . "\n\n" .
                                "Stack Trace:\n" . $e->getTraceAsString() . "\n\n" .
                                "SVG Content:\n" . substr($svgContent, 0, 1000) . "...";
                file_put_contents($errorFile, $errorDetails);
                error_log("Detailed error information saved to: {$errorFile}");
            }
            // Rethrow with a user-friendly message, potentially masking internal details
            throw new Exception('STL conversion failed: ' . $e->getMessage());
        }
    }

    /**
     * Set the extrusion height.
     *
     * @param float $height New extrusion height.
     * @return self For method chaining.
     */
    public function setExtrusionHeight(float $height): self
    {
        $this->extrusionHeight = $height;
        return $this;
    }

    /**
     * Attempt to find the Node.js executable path.
     *
     * @return string|null Path to Node.js or null if not found.
     */
    private function findNodeExecutable(): ?string
    {
        // Common paths for Node.js
        $paths = [
            '/usr/local/bin/node',
            '/usr/bin/node',
            '/opt/homebrew/bin/node', // For Homebrew on Apple Silicon
            '/opt/local/bin/node',   // For MacPorts
        ];

        // Check PATH environment variable
        $pathEnv = getenv('PATH');
        if ($pathEnv) {
            $dirs = explode(PATH_SEPARATOR, $pathEnv);
            foreach ($dirs as $dir) {
                $paths[] = rtrim($dir, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . 'node';
            }
        }

        // Check common Windows paths if applicable (though less likely for server)
        if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {
            $paths[] = 'C:\Program Files\nodejs\node.exe';
            // Add other potential Windows paths
        }

        foreach ($paths as $path) {
            if (is_executable($path)) {
                if ($this->debug) error_log("Found Node.js executable at: " . $path);
                return $path;
            }
        }

        if ($this->debug) error_log("Node.js executable not found in common paths. Defaulting to 'node'.");
        return null; // Default to 'node' hoping it's in the system's PATH
    }

    // --- Removed Methods ---
    // The following methods are no longer needed as their functionality
    // has been moved to the Node.js script (scripts/triangulate.js):
    // - sanitizeSVG
    // - parseSVGPaths
    // - parsePathsDirectly
    // - parsePathData
    // - parseRectsDirectly
    // - parseCirclesDirectly
    // - parsePolygonsDirectly
    // - isBlackOrDark
    // - expandPathForStroke
    // - fallbackTraceMethod
    // - traceBitmap
    // - traceContour
    // - preprocessSVG
    // - flattenGroups
    // - findInkscapePath
    // - processPathElement
    // - processRectElements
    // - processRectElement
    // - createRoundedRect
    // - processCircleElements
    // - processEllipseElements
    // - processPolygonElements
    // - triangulate (original Node.js call removed)
    // - parseAsciiSTL
    // - parseBinarySTL
    // - simpleTriangulate
    // - calculateCentroid
    // - pointInPolygon
    // - isEar
    // - pointInTriangle
    // - generateTriangles
    // - calculatePathArea
    // - scalePath
    // - generateSideWalls
    // - removeDuplicatePoints
    // - generateSTLFile
    // - generateAsciiSTL
    // - generateBinarySTL
    // - formatNumber
}

================
File: src/api/tests/STLConverterTest.php
================
<?php

declare(strict_types=1);

namespace SVG25\Tests;

use PHPUnit\Framework\TestCase;
use SVG25\Services\STLConverter;
use SVG25\Models\Vector3D;
class STLConverterTest extends TestCase
{
    protected function verifyStlFile(string $path, int $minTriangles): void
    {
        $this->assertFileExists($path, "STL file was not created at: $path");
        $content = file_get_contents($path);
        $this->assertStringContainsString('vertex', $content, "STL file does not contain vertices");
        $this->assertStringContainsString('facet normal', $content, "STL file does not contain normal vectors");
        
        $triangleCount = substr_count($content, 'facet normal');
        $this->assertGreaterThanOrEqual($minTriangles, $triangleCount,
            "Expected at least $minTriangles triangles (got $triangleCount)");
            
        // Cleanup after test
        unlink($path);
    }

    public function testCoordinateNormalization()
    {
        $stlConverter = new STLConverter();
        $svgContent = '<svg width="200" height="100">
            <path d="M50,25 L150,25 L150,75 L50,75 Z"/>
        </svg>';
        
        $modelId = 'test_normalization';
        $stlPath = $stlConverter->convertToSTL($svgContent, $modelId);
        $fullPath = __DIR__ . '/../../public/uploads/' . $modelId . '.stl';
        
        $this->verifyStlFile($fullPath, 12);
    }

    public function testExtrusion()
    {
        $stlConverter = new STLConverter();
        $svgContent = '<svg width="100" height="100">
            <path d="M0,0 L0,10 L10,10 L10,0 Z"/>
        </svg>';
        
        $modelId = 'test_extrusion';
        $stlPath = $stlConverter->convertToSTL($svgContent, $modelId);
        $fullPath = __DIR__ . '/../../public/uploads/' . $modelId . '.stl';
        
        $this->verifyStlFile($fullPath, 12);
    }

    public function testComplexShape()
    {
        $stlConverter = new STLConverter();
        $svgContent = '<svg width="100" height="100">
            <path d="M10,10 L20,10 L15,20 Z"/>
            <path d="M30,30 L40,30 L35,40 Z"/>
        </svg>';
        
        $modelId = 'test_complex';
        $stlPath = $stlConverter->convertToSTL($svgContent, $modelId);
        $fullPath = __DIR__ . '/../../public/uploads/' . $modelId . '.stl';
        
        $this->verifyStlFile($fullPath, 16);
    }
}

================
File: src/public/.htaccess
================
# Povolení přepisování URL
RewriteEngine On

# Pokud požadavek začíná /api/, přesměruj na index.php
RewriteCond %{REQUEST_URI} ^/api/
RewriteRule ^(.*)$ index.php [L,QSA]

# Pro všechny ostatní požadavky použij normální soubory
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule ^(.*)$ index.html [L]

================
File: src/public/index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG to STL Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <style>
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden { display: none; }
        .disabled { opacity: 0.5; cursor: not-allowed; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
    <div class="bg-white p-8 rounded-lg shadow-lg w-full max-w-2xl">
        <h1 class="text-3xl font-bold mb-6 text-center text-gray-800">SVG to STL Converter</h1>

        <!-- Step 1: Generate Image -->
        <div id="step1" class="mb-8">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">Krok 1: Generování obrázku</h2>
            <div class="mb-4">
                <label for="prompt" class="block text-sm font-medium text-gray-700 mb-2">Zadejte prompt pro generování obrázku:</label>
                <textarea id="prompt" name="prompt" rows="3" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Např. 'Simple line art drawing of a cat'"></textarea>
            </div>
            <button id="generateButton" class="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 flex items-center justify-center">
                <span id="generateButtonText">Generovat obrázek</span>
                <i id="generateSpinner" class="fas fa-spinner fa-spin ml-2 hidden"></i>
            </button>
            <div id="imagePreview" class="mt-6 hidden text-center">
                <h3 class="text-lg font-medium mb-2 text-gray-700">Vygenerovaný obrázek:</h3>
                <img id="generatedImage" src="" alt="Generated Image" class="max-w-full h-auto mx-auto border border-gray-300 rounded-md shadow-sm">
            </div>
        </div>

        <!-- Step 2: Convert to STL -->
        <div id="step2" class="mb-8 hidden">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">Krok 2: Konverze na STL</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="extrusionHeight" class="block text-sm font-medium text-gray-700 mb-2">
                        Výška extruze (mm)
                    </label>
                    <input
                        type="number"
                        id="extrusionHeight"
                        name="extrusionHeight"
                        value="10"
                        min="1"
                        max="100"
                        step="1"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                </div>
                <div>
                    <label for="stlFormat" class="block text-sm font-medium text-gray-700 mb-2">
                        Formát STL
                    </label>
                    <select
                        id="stlFormat"
                        name="stlFormat"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white"
                    >
                        <option value="ascii">ASCII</option>
                        <option value="binary" selected>Binární (menší soubor)</option>
                    </select>
                </div>
                 <div>
                    <label for="curveSegments" class="block text-sm font-medium text-gray-700 mb-2">
                        Kvalita křivek (segmenty)
                    </label>
                    <input
                        type="number"
                        id="curveSegments"
                        name="curveSegments"
                        value="32"
                        min="4"
                        max="128"
                        step="4"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                </div>
                 <div>
                    <label for="maxSize" class="block text-sm font-medium text-gray-700 mb-2">
                        Cílová velikost (mm)
                    </label>
                    <input
                        type="number"
                        id="maxSize"
                        name="maxSize"
                        value="100"
                        min="10"
                        max="500"
                        step="10"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                </div>
            </div>
            <button id="convertButton" class="w-full bg-green-600 text-white py-2 px-4 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 flex items-center justify-center">
                <span id="convertButtonText">Převést na STL</span>
                <i id="convertSpinner" class="fas fa-spinner fa-spin ml-2 hidden"></i>
            </button>
        </div>

        <!-- Step 3: Download -->
        <div id="step3" class="text-center hidden">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">Krok 3: Stažení modelu</h2>
            <p class="text-gray-600 mb-4">Váš 3D model je připraven ke stažení.</p>
            <a id="downloadLink" href="#" class="inline-block bg-purple-600 text-white py-2 px-6 rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2">
                <i class="fas fa-download mr-2"></i> Stáhnout STL
            </a>
            <button id="resetButton" class="mt-4 w-full bg-gray-500 text-white py-2 px-4 rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">
                Začít znovu
            </button>
        </div>

        <!-- Error Display -->
        <div id="errorDisplay" class="mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-md hidden">
            <strong class="font-bold">Chyba:</strong>
            <span id="errorMessage" class="block sm:inline"></span>
        </div>
    </div>

    <script>
        const step1Div = document.getElementById('step1');
        const step2Div = document.getElementById('step2');
        const step3Div = document.getElementById('step3');
        const generateButton = document.getElementById('generateButton');
        const generateButtonText = document.getElementById('generateButtonText');
        const generateSpinner = document.getElementById('generateSpinner');
        const convertButton = document.getElementById('convertButton');
        const convertButtonText = document.getElementById('convertButtonText');
        const convertSpinner = document.getElementById('convertSpinner');
        const downloadLink = document.getElementById('downloadLink');
        const resetButton = document.getElementById('resetButton');
        const promptInput = document.getElementById('prompt');
        const imagePreviewDiv = document.getElementById('imagePreview');
        const generatedImage = document.getElementById('generatedImage');
        const extrusionHeightInput = document.getElementById('extrusionHeight');
        const stlFormatSelect = document.getElementById('stlFormat');
        const curveSegmentsInput = document.getElementById('curveSegments'); // Get curve segments input
        const maxSizeInput = document.getElementById('maxSize'); // Get max size input
        const errorDisplay = document.getElementById('errorDisplay');
        const errorMessage = document.getElementById('errorMessage');

        let currentImagePath = null; // Store the path for step 2

        function showError(message) {
            errorMessage.textContent = message;
            errorDisplay.classList.remove('hidden');
        }

        function hideError() {
            errorDisplay.classList.add('hidden');
        }

        function setLoading(button, textElement, spinnerElement, isLoading) {
            textElement.textContent = isLoading ? 'Pracuji...' : button.dataset.originalText;
            if (isLoading) {
                spinnerElement.classList.remove('hidden');
                button.classList.add('disabled');
                button.disabled = true;
            } else {
                spinnerElement.classList.add('hidden');
                button.classList.remove('disabled');
                button.disabled = false;
            }
        }

        // Store original button texts
        generateButton.dataset.originalText = generateButtonText.textContent;
        convertButton.dataset.originalText = convertButtonText.textContent;

        // --- Step 1: Generate Image ---
        generateButton.addEventListener('click', async () => {
            const prompt = promptInput.value.trim();
            if (!prompt) {
                showError('Prosím, zadejte prompt.');
                return;
            }
            hideError();
            setLoading(generateButton, generateButtonText, generateSpinner, true);

            try {
                const response = await fetch('/api/generate-image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt })
                });

                const result = await response.json();

                if (!response.ok || result.error) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }

                console.log('Image generated:', result);
                generatedImage.src = result.imageUrl + '?t=' + new Date().getTime(); // Add timestamp to prevent caching
                currentImagePath = result.imagePath; // Save path for next step
                imagePreviewDiv.classList.remove('hidden');
                step2Div.classList.remove('hidden'); // Show step 2

            } catch (error) {
                console.error('Error generating image:', error);
                showError(`Nepodařilo se vygenerovat obrázek: ${error.message}`);
            } finally {
                setLoading(generateButton, generateButtonText, generateSpinner, false);
            }
        });

        // --- Step 2: Convert to STL ---
        async function convertToStl(imagePath, extrusionHeight, stlFormat, curveSegments, maxSize) { // Added curveSegments and maxSize
            hideError();
            setLoading(convertButton, convertButtonText, convertSpinner, true);
            try {
                const response = await fetch('/api/convert-to-stl', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        imagePath,
                        extrusionHeight,
                        stlFormat,
                        curveSegments, // Include curveSegments
                        maxSize        // Include maxSize
                    })
                });

                const result = await response.json();

                if (!response.ok || result.error) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }
                console.log('STL conversion successful:', result);
                return result;

            } catch (error) {
                console.error('Error converting to STL:', error);
                showError(`Nepodařilo se převést na STL: ${error.message}`);
                return null; // Indicate failure
            } finally {
                 setLoading(convertButton, convertButtonText, convertSpinner, false);
            }
        }

        convertButton.addEventListener('click', async () => {
            if (!currentImagePath) {
                showError('Nejprve vygenerujte obrázek.');
                return;
            }
            const extrusionHeight = parseFloat(extrusionHeightInput.value) || 10;
            const stlFormat = stlFormatSelect.value;
            const curveSegments = parseInt(curveSegmentsInput.value) || 32; // Read curveSegments value
            const maxSize = parseFloat(maxSizeInput.value) || 100; // Read maxSize value

            const stlData = await convertToStl(currentImagePath, extrusionHeight, stlFormat, curveSegments, maxSize); // Pass values

            if (stlData && stlData.modelId) {
                downloadLink.href = `/api/download/${stlData.modelId}`;

                // Update download text based on number of files
                if (stlData.files && stlData.files.length > 1) {
                    downloadLink.innerHTML = `<i class="fas fa-download mr-2"></i> Stáhnout ZIP (${stlData.files.length} souborů)`;

                    // Create a list of files
                    const fileListDiv = document.createElement('div');
                    fileListDiv.className = 'mt-4 text-left text-sm text-gray-600';
                    fileListDiv.innerHTML = '<p class="font-semibold mb-2">Vygenerované soubory:</p><ul class="list-disc pl-5"></ul>';

                    const fileList = fileListDiv.querySelector('ul');
                    stlData.files.forEach(file => {
                        const li = document.createElement('li');
                        li.textContent = `${file.color}.stl (${Math.round(file.size / 1024)} KB)`;
                        fileList.appendChild(li);
                    });

                    // Add the file list before the reset button
                    step3Div.insertBefore(fileListDiv, resetButton);
                }

                step3Div.classList.remove('hidden'); // Show download step
            }
        });

        // --- Step 3: Reset ---
        resetButton.addEventListener('click', () => {
            step1Div.classList.remove('hidden');
            step2Div.classList.add('hidden');
            step3Div.classList.add('hidden');
            imagePreviewDiv.classList.add('hidden');
            generatedImage.src = '';
            promptInput.value = '';
            currentImagePath = null;
            hideError();
            // Reset inputs to default values
            extrusionHeightInput.value = '10';
            stlFormatSelect.value = 'binary';
            curveSegmentsInput.value = '32';
            maxSizeInput.value = '100';
        });

    </script>
</body>
</html>

================
File: src/public/index.php
================
<?php
declare(strict_types=1);

require_once __DIR__ . '/../../vendor/autoload.php';

use SVG25\Controllers\GenerateController;
use Dotenv\Dotenv;

// Načtení .env konfigurace
$dotenv = Dotenv::createImmutable(__DIR__ . '/../..');
$dotenv->load();

// Získání požadované cesty
$requestUri = $_SERVER['REQUEST_URI'];
$path = parse_url($requestUri, PHP_URL_PATH);

// Pro API požadavky
if (str_starts_with($path, '/api/')) {
    header('Content-Type: application/json');
    header('Access-Control-Allow-Origin: *');
    header('Access-Control-Allow-Methods: GET, POST, OPTIONS');
    header('Access-Control-Allow-Headers: Content-Type');

    // Zpracování OPTIONS requestu pro CORS
    if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
        exit(0);
    }

    try {
        $method = $_SERVER['REQUEST_METHOD'];

        switch ($path) {
            case '/api/generate-image':
                if ($method === 'POST') {
                    $controller = new GenerateController();
                    echo $controller->generateImage();
                } else {
                    throw new Exception('Method not allowed', 405);
                }
                break;

            case '/api/convert-to-stl':
                if ($method === 'POST') {
                    $controller = new GenerateController();
                    echo $controller->convertToStl();
                } else {
                    throw new Exception('Method not allowed', 405);
                }
                break;

            case (preg_match('/^\/api\/download\/(\w+)$/', $path, $matches) ? true : false):
                if ($method === 'GET') {
                    $controller = new GenerateController();
                    echo $controller->download($matches[1]);
                } else {
                    throw new Exception('Method not allowed', 405);
                }
                break;

            default:
                throw new Exception('Not found', 404);
        }
    } catch (Exception $e) {
        http_response_code($e->getCode() ?: 500);
        echo json_encode([
            'error' => $e->getMessage(),
            'code' => $e->getCode()
        ]);
    }
    exit;
}

// Pro hlavní stránku a ostatní statické soubory
if ($path === '/' || $path === '/index.html') {
    include __DIR__ . '/index.html';
    exit;
}

// Pro ostatní statické soubory
$filePath = __DIR__ . $path;
// Kontrola pro temp složku
if (str_starts_with($path, '/temp/')) {
    $tempPath = $_ENV['UPLOAD_DIR'] . '/temp/' . basename($path);
    if (file_exists($tempPath)) {
        $extension = pathinfo($tempPath, PATHINFO_EXTENSION);
        $mimeType = match ($extension) {
            'png' => 'image/png',
            'jpg', 'jpeg' => 'image/jpeg',
            'svg' => 'image/svg+xml',
            default => 'application/octet-stream',
        };
        header('Content-Type: ' . $mimeType);
        readfile($tempPath);
        exit;
    }
}

if (file_exists($filePath) && !str_ends_with($path, '.php')) {
    $mimeType = match (pathinfo($path, PATHINFO_EXTENSION)) {
        'css' => 'text/css',
        'js' => 'application/javascript',
        'png' => 'image/png',
        'jpg', 'jpeg' => 'image/jpeg',
        'svg' => 'image/svg+xml',
        default => 'application/octet-stream',
    };
    
    header('Content-Type: ' . $mimeType);
    readfile($filePath);
    exit;
}

// Pokud soubor není nalezen
http_response_code(404);
echo '404 Not Found';

================
File: src/public/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-03T11:33:58.652Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.htaccess
index.html
index.php

================================================================
Files
================================================================

================
File: .htaccess
================
# Povolení přepisování URL
RewriteEngine On

# Pokud požadavek začíná /api/, přesměruj na index.php
RewriteCond %{REQUEST_URI} ^/api/
RewriteRule ^(.*)$ index.php [L,QSA]

# Pro všechny ostatní požadavky použij normální soubory
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule ^(.*)$ index.html [L]

================
File: index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG to STL Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <style>
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden { display: none; }
        .disabled { opacity: 0.5; cursor: not-allowed; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
    <div class="bg-white p-8 rounded-lg shadow-lg w-full max-w-2xl">
        <h1 class="text-3xl font-bold mb-6 text-center text-gray-800">SVG to STL Converter</h1>

        <!-- Step 1: Generate Image -->
        <div id="step1" class="mb-8">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">Krok 1: Generování obrázku</h2>
            <div class="mb-4">
                <label for="prompt" class="block text-sm font-medium text-gray-700 mb-2">Zadejte prompt pro generování obrázku:</label>
                <textarea id="prompt" name="prompt" rows="3" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Např. 'Simple line art drawing of a cat'"></textarea>
            </div>
            <button id="generateButton" class="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 flex items-center justify-center">
                <span id="generateButtonText">Generovat obrázek</span>
                <i id="generateSpinner" class="fas fa-spinner fa-spin ml-2 hidden"></i>
            </button>
            <div id="imagePreview" class="mt-6 hidden text-center">
                <h3 class="text-lg font-medium mb-2 text-gray-700">Vygenerovaný obrázek:</h3>
                <img id="generatedImage" src="" alt="Generated Image" class="max-w-full h-auto mx-auto border border-gray-300 rounded-md shadow-sm">
            </div>
        </div>

        <!-- Step 2: Convert to STL -->
        <div id="step2" class="mb-8 hidden">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">Krok 2: Konverze na STL</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="extrusionHeight" class="block text-sm font-medium text-gray-700 mb-2">
                        Výška extruze (mm)
                    </label>
                    <input
                        type="number"
                        id="extrusionHeight"
                        name="extrusionHeight"
                        value="10"
                        min="1"
                        max="100"
                        step="1"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                </div>
                <div>
                    <label for="stlFormat" class="block text-sm font-medium text-gray-700 mb-2">
                        Formát STL
                    </label>
                    <select
                        id="stlFormat"
                        name="stlFormat"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white"
                    >
                        <option value="ascii">ASCII</option>
                        <option value="binary" selected>Binární (menší soubor)</option>
                    </select>
                </div>
                 <div>
                    <label for="curveSegments" class="block text-sm font-medium text-gray-700 mb-2">
                        Kvalita křivek (segmenty)
                    </label>
                    <input
                        type="number"
                        id="curveSegments"
                        name="curveSegments"
                        value="32"
                        min="4"
                        max="128"
                        step="4"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                </div>
                 <div>
                    <label for="maxSize" class="block text-sm font-medium text-gray-700 mb-2">
                        Cílová velikost (mm)
                    </label>
                    <input
                        type="number"
                        id="maxSize"
                        name="maxSize"
                        value="100"
                        min="10"
                        max="500"
                        step="10"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                </div>
            </div>
            <button id="convertButton" class="w-full bg-green-600 text-white py-2 px-4 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 flex items-center justify-center">
                <span id="convertButtonText">Převést na STL</span>
                <i id="convertSpinner" class="fas fa-spinner fa-spin ml-2 hidden"></i>
            </button>
        </div>

        <!-- Step 3: Download -->
        <div id="step3" class="text-center hidden">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">Krok 3: Stažení modelu</h2>
            <p class="text-gray-600 mb-4">Váš 3D model je připraven ke stažení.</p>
            <a id="downloadLink" href="#" class="inline-block bg-purple-600 text-white py-2 px-6 rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2">
                <i class="fas fa-download mr-2"></i> Stáhnout STL
            </a>
            <button id="resetButton" class="mt-4 w-full bg-gray-500 text-white py-2 px-4 rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">
                Začít znovu
            </button>
        </div>

        <!-- Error Display -->
        <div id="errorDisplay" class="mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-md hidden">
            <strong class="font-bold">Chyba:</strong>
            <span id="errorMessage" class="block sm:inline"></span>
        </div>
    </div>

    <script>
        const step1Div = document.getElementById('step1');
        const step2Div = document.getElementById('step2');
        const step3Div = document.getElementById('step3');
        const generateButton = document.getElementById('generateButton');
        const generateButtonText = document.getElementById('generateButtonText');
        const generateSpinner = document.getElementById('generateSpinner');
        const convertButton = document.getElementById('convertButton');
        const convertButtonText = document.getElementById('convertButtonText');
        const convertSpinner = document.getElementById('convertSpinner');
        const downloadLink = document.getElementById('downloadLink');
        const resetButton = document.getElementById('resetButton');
        const promptInput = document.getElementById('prompt');
        const imagePreviewDiv = document.getElementById('imagePreview');
        const generatedImage = document.getElementById('generatedImage');
        const extrusionHeightInput = document.getElementById('extrusionHeight');
        const stlFormatSelect = document.getElementById('stlFormat');
        const curveSegmentsInput = document.getElementById('curveSegments'); // Get curve segments input
        const maxSizeInput = document.getElementById('maxSize'); // Get max size input
        const errorDisplay = document.getElementById('errorDisplay');
        const errorMessage = document.getElementById('errorMessage');

        let currentImagePath = null; // Store the path for step 2

        function showError(message) {
            errorMessage.textContent = message;
            errorDisplay.classList.remove('hidden');
        }

        function hideError() {
            errorDisplay.classList.add('hidden');
        }

        function setLoading(button, textElement, spinnerElement, isLoading) {
            textElement.textContent = isLoading ? 'Pracuji...' : button.dataset.originalText;
            if (isLoading) {
                spinnerElement.classList.remove('hidden');
                button.classList.add('disabled');
                button.disabled = true;
            } else {
                spinnerElement.classList.add('hidden');
                button.classList.remove('disabled');
                button.disabled = false;
            }
        }

        // Store original button texts
        generateButton.dataset.originalText = generateButtonText.textContent;
        convertButton.dataset.originalText = convertButtonText.textContent;

        // --- Step 1: Generate Image ---
        generateButton.addEventListener('click', async () => {
            const prompt = promptInput.value.trim();
            if (!prompt) {
                showError('Prosím, zadejte prompt.');
                return;
            }
            hideError();
            setLoading(generateButton, generateButtonText, generateSpinner, true);

            try {
                const response = await fetch('/api/generate-image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt })
                });

                const result = await response.json();

                if (!response.ok || result.error) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }

                console.log('Image generated:', result);
                generatedImage.src = result.imageUrl + '?t=' + new Date().getTime(); // Add timestamp to prevent caching
                currentImagePath = result.imagePath; // Save path for next step
                imagePreviewDiv.classList.remove('hidden');
                step2Div.classList.remove('hidden'); // Show step 2

            } catch (error) {
                console.error('Error generating image:', error);
                showError(`Nepodařilo se vygenerovat obrázek: ${error.message}`);
            } finally {
                setLoading(generateButton, generateButtonText, generateSpinner, false);
            }
        });

        // --- Step 2: Convert to STL ---
        async function convertToStl(imagePath, extrusionHeight, stlFormat, curveSegments, maxSize) { // Added curveSegments and maxSize
            hideError();
            setLoading(convertButton, convertButtonText, convertSpinner, true);
            try {
                const response = await fetch('/api/convert-to-stl', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        imagePath,
                        extrusionHeight,
                        stlFormat,
                        curveSegments, // Include curveSegments
                        maxSize        // Include maxSize
                    })
                });

                const result = await response.json();

                if (!response.ok || result.error) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }
                console.log('STL conversion successful:', result);
                return result;

            } catch (error) {
                console.error('Error converting to STL:', error);
                showError(`Nepodařilo se převést na STL: ${error.message}`);
                return null; // Indicate failure
            } finally {
                 setLoading(convertButton, convertButtonText, convertSpinner, false);
            }
        }

        convertButton.addEventListener('click', async () => {
            if (!currentImagePath) {
                showError('Nejprve vygenerujte obrázek.');
                return;
            }
            const extrusionHeight = parseFloat(extrusionHeightInput.value) || 10;
            const stlFormat = stlFormatSelect.value;
            const curveSegments = parseInt(curveSegmentsInput.value) || 32; // Read curveSegments value
            const maxSize = parseFloat(maxSizeInput.value) || 100; // Read maxSize value

            const stlData = await convertToStl(currentImagePath, extrusionHeight, stlFormat, curveSegments, maxSize); // Pass values

            if (stlData && stlData.modelId) {
                downloadLink.href = `/api/download/${stlData.modelId}`;

                // Update download text based on number of files
                if (stlData.files && stlData.files.length > 1) {
                    downloadLink.innerHTML = `<i class="fas fa-download mr-2"></i> Stáhnout ZIP (${stlData.files.length} souborů)`;

                    // Create a list of files
                    const fileListDiv = document.createElement('div');
                    fileListDiv.className = 'mt-4 text-left text-sm text-gray-600';
                    fileListDiv.innerHTML = '<p class="font-semibold mb-2">Vygenerované soubory:</p><ul class="list-disc pl-5"></ul>';

                    const fileList = fileListDiv.querySelector('ul');
                    stlData.files.forEach(file => {
                        const li = document.createElement('li');
                        li.textContent = `${file.color}.stl (${Math.round(file.size / 1024)} KB)`;
                        fileList.appendChild(li);
                    });

                    // Add the file list before the reset button
                    step3Div.insertBefore(fileListDiv, resetButton);
                }

                step3Div.classList.remove('hidden'); // Show download step
            }
        });

        // --- Step 3: Reset ---
        resetButton.addEventListener('click', () => {
            step1Div.classList.remove('hidden');
            step2Div.classList.add('hidden');
            step3Div.classList.add('hidden');
            imagePreviewDiv.classList.add('hidden');
            generatedImage.src = '';
            promptInput.value = '';
            currentImagePath = null;
            hideError();
            // Reset inputs to default values
            extrusionHeightInput.value = '10';
            stlFormatSelect.value = 'binary';
            curveSegmentsInput.value = '32';
            maxSizeInput.value = '100';
        });

    </script>
</body>
</html>

================
File: index.php
================
<?php
declare(strict_types=1);

require_once __DIR__ . '/../../vendor/autoload.php';

use SVG25\Controllers\GenerateController;
use Dotenv\Dotenv;

// Načtení .env konfigurace
$dotenv = Dotenv::createImmutable(__DIR__ . '/../..');
$dotenv->load();

// Získání požadované cesty
$requestUri = $_SERVER['REQUEST_URI'];
$path = parse_url($requestUri, PHP_URL_PATH);

// Pro API požadavky
if (str_starts_with($path, '/api/')) {
    header('Content-Type: application/json');
    header('Access-Control-Allow-Origin: *');
    header('Access-Control-Allow-Methods: GET, POST, OPTIONS');
    header('Access-Control-Allow-Headers: Content-Type');

    // Zpracování OPTIONS requestu pro CORS
    if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
        exit(0);
    }

    try {
        $method = $_SERVER['REQUEST_METHOD'];

        switch ($path) {
            case '/api/generate-image':
                if ($method === 'POST') {
                    $controller = new GenerateController();
                    echo $controller->generateImage();
                } else {
                    throw new Exception('Method not allowed', 405);
                }
                break;

            case '/api/convert-to-stl':
                if ($method === 'POST') {
                    $controller = new GenerateController();
                    echo $controller->convertToStl();
                } else {
                    throw new Exception('Method not allowed', 405);
                }
                break;

            case (preg_match('/^\/api\/download\/(\w+)$/', $path, $matches) ? true : false):
                if ($method === 'GET') {
                    $controller = new GenerateController();
                    echo $controller->download($matches[1]);
                } else {
                    throw new Exception('Method not allowed', 405);
                }
                break;

            default:
                throw new Exception('Not found', 404);
        }
    } catch (Exception $e) {
        http_response_code($e->getCode() ?: 500);
        echo json_encode([
            'error' => $e->getMessage(),
            'code' => $e->getCode()
        ]);
    }
    exit;
}

// Pro hlavní stránku a ostatní statické soubory
if ($path === '/' || $path === '/index.html') {
    include __DIR__ . '/index.html';
    exit;
}

// Pro ostatní statické soubory
$filePath = __DIR__ . $path;
// Kontrola pro temp složku
if (str_starts_with($path, '/temp/')) {
    $tempPath = $_ENV['UPLOAD_DIR'] . '/temp/' . basename($path);
    if (file_exists($tempPath)) {
        $extension = pathinfo($tempPath, PATHINFO_EXTENSION);
        $mimeType = match ($extension) {
            'png' => 'image/png',
            'jpg', 'jpeg' => 'image/jpeg',
            'svg' => 'image/svg+xml',
            default => 'application/octet-stream',
        };
        header('Content-Type: ' . $mimeType);
        readfile($tempPath);
        exit;
    }
}

if (file_exists($filePath) && !str_ends_with($path, '.php')) {
    $mimeType = match (pathinfo($path, PATHINFO_EXTENSION)) {
        'css' => 'text/css',
        'js' => 'application/javascript',
        'png' => 'image/png',
        'jpg', 'jpeg' => 'image/jpeg',
        'svg' => 'image/svg+xml',
        default => 'application/octet-stream',
    };
    
    header('Content-Type: ' . $mimeType);
    readfile($filePath);
    exit;
}

// Pokud soubor není nalezen
http_response_code(404);
echo '404 Not Found';

================
File: test_data/problematic.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="210.746" height="281.063" viewBox="0 0 210.746 281.063"><defs><style>.a{fill:none;}.b{clip-path:url(#a);}.c{fill:#c71a1a;}.d{fill:#faa61a;}.e{fill:#2459ab;}.f{fill:#fff;}.g{fill:#c7ab59;}</style><clipPath id="a"><rect class="a" width="210.746" height="281.063"/></clipPath></defs><g class="b" transform="translate(0 0)"><path class="c" d="M127.994,155.684l-5.408-5.408L118.61,146.3A92.092,92.092,0,0,1,83.3,166.659l1.591,5.408,2.227,7.317.954,3.022a108.474,108.474,0,0,0,42.149-24.335Z" transform="translate(49.191 86.395)"/><path class="d" d="M98.775,173.024l-2.227-7.316L94.958,160.3a93.045,93.045,0,0,1-39.286,0l-1.591,5.408-2.227,7.316-.954,3.022a109.588,109.588,0,0,0,48.829,0Z" transform="translate(30.058 94.662)"/><path class="e" d="M31.311,146.3l-3.976,3.976-5.408,5.408L19.7,157.911a108.474,108.474,0,0,0,42.149,24.494l.954-3.022,2.227-7.317,1.591-5.408A92.091,92.091,0,0,1,31.311,146.3" transform="translate(11.633 86.395)"/><path d="M137.293,246.8l-.954-3.022-2.227-7.316-1.591-5.408a92.092,92.092,0,0,0,35.31-20.359l3.976,3.976,5.408,5.408,2.227,2.227A108.475,108.475,0,0,1,137.293,246.8M105.482,50.842A92.092,92.092,0,0,0,35.976,203.374l1.909,2.227-3.976,3.976L31.84,207.35a97.818,97.818,0,1,1,147.124,0l-1.909,2.227L173.08,205.6l1.909-2.227A92.092,92.092,0,0,0,105.482,50.842m0,200.725a108.951,108.951,0,0,1-24.494-2.7l.954-3.022,2.227-7.316,1.591-5.408a93.045,93.045,0,0,0,39.286,0l1.591,5.408,2.227,7.316.954,3.022a108.951,108.951,0,0,1-24.335,2.7m-28.789-15.11-2.227,7.316-.954,3.022a108.475,108.475,0,0,1-42.149-24.335l2.227-2.227L39,214.826l3.976-3.976a92.091,92.091,0,0,0,35.31,20.359Zm105.77-21.631,1.909-2.227a105.452,105.452,0,1,0-157.94,0l1.909,2.227-2.227,2.227-5.408,5.408,5.249,5.249a115.95,115.95,0,0,0,45.33,26.244l7.475,2.068a117.062,117.062,0,0,0,53.283,0l7.475-2.068a115.95,115.95,0,0,0,45.33-26.244l5.249-5.249-5.408-5.408Z" transform="translate(-0.03 22.004)"/><path class="f" d="M105.061,102.987l22.745,6.044v-14A27.834,27.834,0,0,0,99.972,67.2H65.934A27.834,27.834,0,0,0,38.1,95.034v8.271c0,11.929,6.68,23.54,22.108,27.675l39.6,10.5a6.362,6.362,0,0,1,5.249,6.362v10.338a5.09,5.09,0,0,1-5.09,5.09H65.934a5.09,5.09,0,0,1-5.09-5.09V147.84l-22.745-6.2v13.838a27.834,27.834,0,0,0,27.834,27.834H99.972a27.834,27.834,0,0,0,27.834-27.834v-8.112c0-11.929-6.68-23.54-22.108-27.675l-39.763-10.5a6.362,6.362,0,0,1-5.249-6.362V92.489a4.772,4.772,0,0,1,5.09-5.09h34.2a5.09,5.09,0,0,1,5.09,5.09Z" transform="translate(22.499 39.684)"/><path class="f" d="M102.629,42.2A97.818,97.818,0,0,0,28.987,204.434l1.909,2.227,3.976-3.976-1.909-2.227a92.092,92.092,0,1,1,139.172,0l-1.909,2.227,3.976,3.976,1.909-2.227A97.818,97.818,0,0,0,102.47,42.2" transform="translate(2.823 24.92)"/><path class="g" d="M81.83,24.494,94.554,15.11H78.808L73.877,0,68.946,15.11H53.2l12.724,9.384L60.994,39.763l12.883-9.384L86.76,39.763Z" transform="translate(31.416)"/><path class="g" d="M112.549,34.849l15.587-2.386-14-7.316,2.7-15.746L105.55,20.693l-14-7.316,7,14.156L87.1,38.825l15.746-2.545L110,50.595Z" transform="translate(51.435 5.551)"/><path class="g" d="M35.187,34.849,19.6,32.463l14-7.316L30.893,9.4,42.345,20.693l14-7.316-7,14.156L60.636,38.825,44.889,36.28,37.732,50.595Z" transform="translate(11.574 5.551)"/></g></svg>

================
File: .env.example
================
# API klíč pro Google Gemini API
GEMINI_API_KEY=your-api-key-here

# Konfigurace aplikace 
APP_ENV=development
APP_DEBUG=true
UPLOAD_DIR=src/public/uploads

# Nastavení konverze
MAX_IMAGE_SIZE=5242880  # 5MB v bytech
DEFAULT_EXTRUSION_HEIGHT=1
RATE_LIMIT_REQUESTS=100
RATE_LIMIT_WINDOW=3600  # 1 hodina v sekundách

================
File: .gitignore
================
/vendor/
/node_modules/
.env
.phpunit.result.cache
.idea/
.vscode/
*.log
/src/public/uploads/
composer.lock
package-lock.json

================
File: check_svg.php
================
<?php
// Enable error reporting
ini_set('display_errors', 1);
ini_set('display_startup_errors', 1);
error_reporting(E_ALL);

// Find the most recent SVG file in the temp directory
$tempDir = __DIR__ . '/src/public/uploads/temp';
$svgFiles = glob($tempDir . '/*.svg');

if (empty($svgFiles)) {
    echo "No SVG files found in $tempDir\n";
    exit(1);
}

// Sort by modification time (newest first)
usort($svgFiles, function($a, $b) {
    return filemtime($b) - filemtime($a);
});

$latestSvg = $svgFiles[0];
echo "Examining SVG file: $latestSvg\n";
echo "File size: " . filesize($latestSvg) . " bytes\n";
echo "Last modified: " . date('Y-m-d H:i:s', filemtime($latestSvg)) . "\n\n";

// Read the SVG content
$svgContent = file_get_contents($latestSvg);
if ($svgContent === false) {
    echo "Failed to read SVG file\n";
    exit(1);
}

// Display the SVG content
echo "SVG Content:\n";
echo "------------\n";
echo $svgContent . "\n\n";

// Check for SVG elements
echo "SVG Element Analysis:\n";
echo "--------------------\n";

// Check for paths
preg_match_all('/<path[^>]*>/', $svgContent, $pathMatches);
echo "Number of <path> elements: " . count($pathMatches[0]) . "\n";
if (count($pathMatches[0]) > 0) {
    echo "First path: " . $pathMatches[0][0] . "\n";
}

// Check for polygons
preg_match_all('/<polygon[^>]*>/', $svgContent, $polygonMatches);
echo "Number of <polygon> elements: " . count($polygonMatches[0]) . "\n";
if (count($polygonMatches[0]) > 0) {
    echo "First polygon: " . $polygonMatches[0][0] . "\n";
}

// Check for g elements (groups)
preg_match_all('/<g[^>]*>/', $svgContent, $gMatches);
echo "Number of <g> elements: " . count($gMatches[0]) . "\n";
if (count($gMatches[0]) > 0) {
    echo "First group: " . $gMatches[0][0] . "\n";
}

// Check for other potential elements
$otherElements = ['rect', 'circle', 'ellipse', 'line', 'polyline'];
foreach ($otherElements as $element) {
    preg_match_all('/<' . $element . '[^>]*>/', $svgContent, $matches);
    echo "Number of <$element> elements: " . count($matches[0]) . "\n";
    if (count($matches[0]) > 0) {
        echo "First $element: " . $matches[0][0] . "\n";
    }
}

================
File: composer.json
================
{
    "repositories": [
        {
            "type": "vcs",
            "url": "https://github.com/meyfa/php-svg"
        }
    ],
    "require": {
        "php": ">=7.4",
        "meyfa/php-svg": "^0.16.1",
        "vlucas/phpdotenv": "^5.6.1",
        "guzzlehttp/guzzle": "^7.9"
    },
    "autoload": {
        "psr-4": {
            "SVG25\\": "src/api/"
        }
    }
}

================
File: package.json
================
{
  "dependencies": {
    "three": "^0.174.0"
  }
}

================
File: plan.md
================
# Plán Vylepšení Převodu SVG Křivek na STL v Aplikaci SVG 2.5

## 1. Porozumění Stávajícímu Kódu a Technologiím:

*   **Cíl:** Získat hlubší vhled do fungování `STLConverter.php` a `triangulate.js`, abychom pochopili, jak aktuálně probíhá konverze SVG na STL.
*   **Nástroje:** `read_file`, `list_code_definition_names`
*   **Kroky:**
    *   Prohlédnout si `STLConverter.php` a `triangulate.js` pomocí `read_file`, abychom pochopili, jak se SVG data zpracovávají a jak se generuje STL. (Již provedeno)
    *   Použít `list_code_definition_names` na `src/api/services/` a `scripts/` pro získání přehledu o definovaných třídách a funkcích. (Již provedeno)
    *   Ověřit, zda se v projektu používá three.js. (Nepoužívá se.)

## 2. Návrh Nového Modulu pro Subdivizi Křivek a Převod na STL (Three.js):

*   **Cíl:** Navrhnout strukturu nového Node.js modulu, který bude zodpovědný za přesnou aproximaci křivek a převod na STL pomocí Three.js.
*   **Nástroje:** Žádné (pouze myšlenkový proces)
*   **Kroky:**
    *   Rozhodnout, zda upravit stávající `triangulate.js` nebo vytvořit nový modul. (Navrhuji upravit stávající `triangulate.js`, aby se minimalizovala složitost integrace.)
    *   Definovat rozhraní modulu: jaké vstupy bude přijímat (SVG data, parametry detailu) a jaké výstupy bude vracet (STL data). (Vstup: JSON s SVG path data a parametrem detailu. Výstup: STL data jako řetězec nebo Buffer.)
    *   Použít Three.js pro parsování SVG path dat, subdivizi křivek a export do STL.

## 3. Implementace Převodu SVG na STL pomocí Three.js v Node.js:

*   **Cíl:** Implementovat algoritmy pro převod SVG na STL pomocí Three.js.
*   **Nástroje:** `write_to_file`
*   **Kroky:**
    *   Upravit stávající `triangulate.js` s implementací převodu pomocí Three.js.
    *   Nainstalovat Three.js do projektu pomocí `npm install three`.
    *   Použít `SVGLoader` pro načtení SVG dat.
    *   Použít `THREE.Shape` a `THREE.ExtrudeGeometry` (nebo `ShapeGeometry`) pro vytvoření 3D geometrie.
    *   Použít `STLExporter` pro export do STL formátu.

## 4. Integrace s PHP:

*   **Cíl:** Upravit PHP kód tak, aby volal nový/upravený Node.js skript a získal STL data.
*   **Nástroje:** `apply_diff`
*   **Kroky:**
    *   Upravit `STLConverter.php` tak, aby volal Node.js skript pomocí `proc_open` nebo podobného mechanismu.
    *   Předávat SVG data a parametry detailu do Node.js skriptu.
    *   Přijímat STL data z Node.js skriptu.
    *   Upravit `STLConverter.php` tak, aby používal STL data pro generování STL souboru.

## 5. Konfigurovatelnost Detailu:

*   **Cíl:** Umožnit nastavit úroveň detailu aproximace křivek (pokud je to relevantní pro Three.js).
*   **Nástroje:** `apply_diff`
*   **Kroky:**
    *   Přidat parametr pro nastavení detailu do Node.js skriptu (pokud je to relevantní pro Three.js).
    *   Zvážit přidání této konfigurace do `.env` souboru.
    *   Upravit PHP kód tak, aby předával parametr detailu do Node.js skriptu.

## 6. Revize Preprocessingu (Volitelné):

*   **Cíl:** Zkontrolovat nastavení `potrace` v `ImageProcessor.php` a volby `Inkscape`.
*   **Nástroje:** `read_file`, `apply_diff`
*   **Kroky:**
    *   Prohlédnout si `ImageProcessor.php` pomocí `read_file`.
    *   Experimentovat s parametry `potrace` a volbami `Inkscape` pro nalezení optimálního nastavení.
    *   Upravit `ImageProcessor.php` pomocí `apply_diff`, pokud je to nutné.

## 7. Robustnost a Ošetření Chyb:

*   **Cíl:** Zajistit robustní zpracování různých SVG souborů a správné ošetření chyb.
*   **Nástroje:** Žádné (pouze myšlenkový proces a testování)
*   **Kroky:**
    *   Testovat na různých SVG souborech (jednoduché tvary, komplexní křivky, kombinace).
    *   Implementovat ošetření chyb při komunikaci mezi PHP a Node.js a při samotném zpracování v Node.js.

## 8. Dokumentace:

*   **Cíl:** Vytvořit stručnou dokumentaci k novému nastavení úrovně detailu (pokud bude implementováno).
*   **Nástroje:** `write_to_file`
*   **Kroky:**
    *   Vytvořit nový soubor s dokumentací nebo upravit stávající.

## Použité Knihovny:

*   `three`: Pro 3D grafiku a export do STL.
*   `three/addons/loaders/SVGLoader.js`: Pro načítání SVG dat.
*   `three/addons/exporters/STLExporter.js`: Pro export do STL formátu.
*   `node:fs/promises`: Pro práci se soubory v Node.js.

## Poznámky:

*   Projekt nepoužívá three.js, bude nutné jej nainstalovat.

## Mermaid Diagram:

```mermaid
graph TD
    A[Porozumění Stávajícímu Kódu] --> B{Návrh Nového Modulu (Three.js)};
    B --> C[Implementace Převodu SVG na STL (Three.js)];
    C --> D[Integrace s PHP];
    D --> E{Konfigurovatelnost Detailu};
    E --> F[Revize Preprocessingu (Volitelné)];
    F --> G[Robustnost a Ošetření Chyb];
    G --> H[Dokumentace];
    H --> I(Hotovo);
    style B fill:#f9f,stroke:#333,stroke-width:2px

================
File: refined_plan.md
================
# Refined Project Plan: SVG 2.5 Improvement

This plan outlines the steps to improve the SVG to STL conversion process and address other project goals.

## 1. Information Gathering & Context

*   **Status:** Mostly Complete
*   **Actions:**
    *   Reviewed `plan.md`, `src/api/services/STLConverter.php`, `scripts/triangulate.js`.
    *   Clarified filter purpose: Selects main shapes from varied SVGs.
*   **Pending:** Await sample problematic SVG from the user for testing.

## 2. Core Fix: Revise Geometry Generation in `scripts/triangulate.js`

*   **Problem:** Current use of `THREE.ExtrudeGeometry` likely creates overlapping or non-manifold meshes when multiple SVG shapes are extruded independently.
*   **Proposed Solution:** Implement Constructive Solid Geometry (CSG).
    *   Continue using `SVGLoader` and `ExtrudeGeometry` for initial mesh creation from filtered SVG shapes.
    *   **Key Change:** Use a CSG library (e.g., `three-bvh-csg`) to perform a **boolean union** operation on *all* extruded meshes. This aims to merge them into a single, solid, and watertight object.
    *   Center and scale the final *merged* mesh.
    *   Remove `THREE.DoubleSide` material during development/testing to better identify potential face orientation issues.

## 3. Implementation Steps (Primarily in `scripts/triangulate.js`)

*   Install the necessary CSG library (e.g., `npm install three-bvh-csg` within the `scripts` directory).
*   Modify the script logic to incorporate the CSG union step after extrusion and before scaling/exporting.

## 4. Testing & Validation

*   Use the provided sample problematic SVG as the primary test case.
*   Test with other diverse SVG examples if possible.
*   Analyze generated STL files using external 3D modeling software (e.g., MeshLab, Blender, Windows 3D Builder) to verify:
    *   **Geometric Accuracy:** Visual match to SVG.
    *   **Watertightness:** Manifold check (no holes).
    *   **Solidity:** Correct normals, no internal faces.

## 5. Address Other Project Goals (After Core Fix Validation)

*   **Code Review:** Analyze other relevant files (e.g., `GenerateController.php`, `ImageProcessor.php`) for complexity, readability, and potential improvements. Refactor if necessary.
*   **Performance Analysis:** Assess application performance (response time, resource usage) if the conversion process remains slow after the fix, and implement optimizations.
*   **Testing:** Create/update comprehensive unit and integration tests (e.g., for `STLConverter.php` and Node.js script interaction) to ensure robustness.

## 6. Updated Flow Diagram

```mermaid
graph TD
    subgraph Planning & Analysis (Architect Mode)
        A[Initial Request] --> B(Review plan.md);
        B --> C(Analyze STLConverter.php);
        C --> D(Analyze triangulate.js);
        D --> E{Clarify Filter & Get Sample SVG};
        E --> F(Refine Plan: Use CSG Union);
        F --> G{User Approval of Plan?};
    end

    subgraph Implementation & Testing (Code/Debug Mode)
        H[Start triangulate.js] --> I(Parse SVG);
        I --> J{Filter Shapes};
        J --> K[Extrude Shapes Individually];
        K --> L(Collect Meshes);
        L --> M[Perform CSG Union];
        M --> N[Center/Scale Merged Mesh];
        N --> O(Export STL);
        O --> P[Test with Sample SVG];
        P --> Q{Analyze STL Output};
        Q -- Issues --> M;
        Q -- OK --> R(Address Other Goals: Review, Perf, Tests);
    end

    G -- Yes --> H; %% Changed from R to H to show transition
    style M fill:#ccffcc,stroke:#333,stroke-width:2px
